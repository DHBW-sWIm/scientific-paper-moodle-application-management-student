<?php
/**
 * ModelsApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   http://github.com/swagger-api/swagger-codegen
 * @license  http://www.apache.org/licenses/LICENSE-2.0 Apache License v2
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * sWIm Activiti REST API
 *
 * here be dragons
 *
 * OpenAPI spec version: v0.2.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * ModelsApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   http://github.com/swagger-api/swagger-codegen
 * @license  http://www.apache.org/licenses/LICENSE-2.0 Apache License v2
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class ModelsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation createModel
     *
     * Create a model
     *
     * @param  \Swagger\Client\Model\ModelRequest $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ModelResponse
     */
    public function createModel($body = null)
    {
        list($response) = $this->createModelWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation createModelWithHttpInfo
     *
     * Create a model
     *
     * @param  \Swagger\Client\Model\ModelRequest $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ModelResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createModelWithHttpInfo($body = null)
    {
        $returnType = '\Swagger\Client\Model\ModelResponse';
        $request = $this->createModelRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ModelResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createModelAsync
     *
     * Create a model
     *
     * @param  \Swagger\Client\Model\ModelRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createModelAsync($body = null)
    {
        return $this->createModelAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createModelAsyncWithHttpInfo
     *
     * Create a model
     *
     * @param  \Swagger\Client\Model\ModelRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createModelAsyncWithHttpInfo($body = null)
    {
        $returnType = '\Swagger\Client\Model\ModelResponse';
        $request = $this->createModelRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createModel'
     *
     * @param  \Swagger\Client\Model\ModelRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createModelRequest($body = null)
    {

        $resourcePath = '/repository/models';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteModel
     *
     * Delete a model
     *
     * @param  string $model_id The id of the model to delete. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteModel($model_id)
    {
        $this->deleteModelWithHttpInfo($model_id);
    }

    /**
     * Operation deleteModelWithHttpInfo
     *
     * Delete a model
     *
     * @param  string $model_id The id of the model to delete. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteModelWithHttpInfo($model_id)
    {
        $returnType = '';
        $request = $this->deleteModelRequest($model_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteModelAsync
     *
     * Delete a model
     *
     * @param  string $model_id The id of the model to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteModelAsync($model_id)
    {
        return $this->deleteModelAsyncWithHttpInfo($model_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteModelAsyncWithHttpInfo
     *
     * Delete a model
     *
     * @param  string $model_id The id of the model to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteModelAsyncWithHttpInfo($model_id)
    {
        $returnType = '';
        $request = $this->deleteModelRequest($model_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteModel'
     *
     * @param  string $model_id The id of the model to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteModelRequest($model_id)
    {
        // verify the required parameter 'model_id' is set
        if ($model_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $model_id when calling deleteModel'
            );
        }

        $resourcePath = '/repository/models/{modelId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($model_id !== null) {
            $resourcePath = str_replace(
                '{' . 'modelId' . '}',
                ObjectSerializer::toPathValue($model_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getModel
     *
     * Get a model
     *
     * @param  string $model_id The id of the model to get. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ModelResponse
     */
    public function getModel($model_id)
    {
        list($response) = $this->getModelWithHttpInfo($model_id);
        return $response;
    }

    /**
     * Operation getModelWithHttpInfo
     *
     * Get a model
     *
     * @param  string $model_id The id of the model to get. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ModelResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getModelWithHttpInfo($model_id)
    {
        $returnType = '\Swagger\Client\Model\ModelResponse';
        $request = $this->getModelRequest($model_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ModelResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getModelAsync
     *
     * Get a model
     *
     * @param  string $model_id The id of the model to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getModelAsync($model_id)
    {
        return $this->getModelAsyncWithHttpInfo($model_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getModelAsyncWithHttpInfo
     *
     * Get a model
     *
     * @param  string $model_id The id of the model to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getModelAsyncWithHttpInfo($model_id)
    {
        $returnType = '\Swagger\Client\Model\ModelResponse';
        $request = $this->getModelRequest($model_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getModel'
     *
     * @param  string $model_id The id of the model to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getModelRequest($model_id)
    {
        // verify the required parameter 'model_id' is set
        if ($model_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $model_id when calling getModel'
            );
        }

        $resourcePath = '/repository/models/{modelId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($model_id !== null) {
            $resourcePath = str_replace(
                '{' . 'modelId' . '}',
                ObjectSerializer::toPathValue($model_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getModels
     *
     * Get a list of models
     *
     * @param  string $id Only return models with the given version. (optional)
     * @param  string $category Only return models with the given category. (optional)
     * @param  string $category_like Only return models with a category like the given name. (optional)
     * @param  string $category_not_equals Only return models which don�t have the given category. (optional)
     * @param  string $name Only return models with the given name. (optional)
     * @param  string $name_like Only return models with a name like the given name. (optional)
     * @param  string $key Only return models with the given key. (optional)
     * @param  string $deployment_id Only return models with the given category. (optional)
     * @param  int $version Only return models with the given version. (optional)
     * @param  bool $latest_version If true, only return models which are the latest version. Best used in combination with key. If false is passed in as value, this is ignored and all versions are returned. (optional)
     * @param  bool $deployed If true, only deployed models are returned. If false, only undeployed models are returned (deploymentId is null). (optional)
     * @param  string $tenant_id Only return models with the given tenantId. (optional)
     * @param  string $tenant_id_like Only return models with a tenantId like the given value. (optional)
     * @param  bool $without_tenant_id If true, only returns models without a tenantId set. If false, the withoutTenantId parameter is ignored. (optional)
     * @param  string $sort Property to sort on, to be used together with the order. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\DataResponse
     */
    public function getModels($id = null, $category = null, $category_like = null, $category_not_equals = null, $name = null, $name_like = null, $key = null, $deployment_id = null, $version = null, $latest_version = null, $deployed = null, $tenant_id = null, $tenant_id_like = null, $without_tenant_id = null, $sort = null)
    {
        list($response) = $this->getModelsWithHttpInfo($id, $category, $category_like, $category_not_equals, $name, $name_like, $key, $deployment_id, $version, $latest_version, $deployed, $tenant_id, $tenant_id_like, $without_tenant_id, $sort);
        return $response;
    }

    /**
     * Operation getModelsWithHttpInfo
     *
     * Get a list of models
     *
     * @param  string $id Only return models with the given version. (optional)
     * @param  string $category Only return models with the given category. (optional)
     * @param  string $category_like Only return models with a category like the given name. (optional)
     * @param  string $category_not_equals Only return models which don�t have the given category. (optional)
     * @param  string $name Only return models with the given name. (optional)
     * @param  string $name_like Only return models with a name like the given name. (optional)
     * @param  string $key Only return models with the given key. (optional)
     * @param  string $deployment_id Only return models with the given category. (optional)
     * @param  int $version Only return models with the given version. (optional)
     * @param  bool $latest_version If true, only return models which are the latest version. Best used in combination with key. If false is passed in as value, this is ignored and all versions are returned. (optional)
     * @param  bool $deployed If true, only deployed models are returned. If false, only undeployed models are returned (deploymentId is null). (optional)
     * @param  string $tenant_id Only return models with the given tenantId. (optional)
     * @param  string $tenant_id_like Only return models with a tenantId like the given value. (optional)
     * @param  bool $without_tenant_id If true, only returns models without a tenantId set. If false, the withoutTenantId parameter is ignored. (optional)
     * @param  string $sort Property to sort on, to be used together with the order. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\DataResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getModelsWithHttpInfo($id = null, $category = null, $category_like = null, $category_not_equals = null, $name = null, $name_like = null, $key = null, $deployment_id = null, $version = null, $latest_version = null, $deployed = null, $tenant_id = null, $tenant_id_like = null, $without_tenant_id = null, $sort = null)
    {
        $returnType = '\Swagger\Client\Model\DataResponse';
        $request = $this->getModelsRequest($id, $category, $category_like, $category_not_equals, $name, $name_like, $key, $deployment_id, $version, $latest_version, $deployed, $tenant_id, $tenant_id_like, $without_tenant_id, $sort);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\DataResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getModelsAsync
     *
     * Get a list of models
     *
     * @param  string $id Only return models with the given version. (optional)
     * @param  string $category Only return models with the given category. (optional)
     * @param  string $category_like Only return models with a category like the given name. (optional)
     * @param  string $category_not_equals Only return models which don�t have the given category. (optional)
     * @param  string $name Only return models with the given name. (optional)
     * @param  string $name_like Only return models with a name like the given name. (optional)
     * @param  string $key Only return models with the given key. (optional)
     * @param  string $deployment_id Only return models with the given category. (optional)
     * @param  int $version Only return models with the given version. (optional)
     * @param  bool $latest_version If true, only return models which are the latest version. Best used in combination with key. If false is passed in as value, this is ignored and all versions are returned. (optional)
     * @param  bool $deployed If true, only deployed models are returned. If false, only undeployed models are returned (deploymentId is null). (optional)
     * @param  string $tenant_id Only return models with the given tenantId. (optional)
     * @param  string $tenant_id_like Only return models with a tenantId like the given value. (optional)
     * @param  bool $without_tenant_id If true, only returns models without a tenantId set. If false, the withoutTenantId parameter is ignored. (optional)
     * @param  string $sort Property to sort on, to be used together with the order. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getModelsAsync($id = null, $category = null, $category_like = null, $category_not_equals = null, $name = null, $name_like = null, $key = null, $deployment_id = null, $version = null, $latest_version = null, $deployed = null, $tenant_id = null, $tenant_id_like = null, $without_tenant_id = null, $sort = null)
    {
        return $this->getModelsAsyncWithHttpInfo($id, $category, $category_like, $category_not_equals, $name, $name_like, $key, $deployment_id, $version, $latest_version, $deployed, $tenant_id, $tenant_id_like, $without_tenant_id, $sort)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getModelsAsyncWithHttpInfo
     *
     * Get a list of models
     *
     * @param  string $id Only return models with the given version. (optional)
     * @param  string $category Only return models with the given category. (optional)
     * @param  string $category_like Only return models with a category like the given name. (optional)
     * @param  string $category_not_equals Only return models which don�t have the given category. (optional)
     * @param  string $name Only return models with the given name. (optional)
     * @param  string $name_like Only return models with a name like the given name. (optional)
     * @param  string $key Only return models with the given key. (optional)
     * @param  string $deployment_id Only return models with the given category. (optional)
     * @param  int $version Only return models with the given version. (optional)
     * @param  bool $latest_version If true, only return models which are the latest version. Best used in combination with key. If false is passed in as value, this is ignored and all versions are returned. (optional)
     * @param  bool $deployed If true, only deployed models are returned. If false, only undeployed models are returned (deploymentId is null). (optional)
     * @param  string $tenant_id Only return models with the given tenantId. (optional)
     * @param  string $tenant_id_like Only return models with a tenantId like the given value. (optional)
     * @param  bool $without_tenant_id If true, only returns models without a tenantId set. If false, the withoutTenantId parameter is ignored. (optional)
     * @param  string $sort Property to sort on, to be used together with the order. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getModelsAsyncWithHttpInfo($id = null, $category = null, $category_like = null, $category_not_equals = null, $name = null, $name_like = null, $key = null, $deployment_id = null, $version = null, $latest_version = null, $deployed = null, $tenant_id = null, $tenant_id_like = null, $without_tenant_id = null, $sort = null)
    {
        $returnType = '\Swagger\Client\Model\DataResponse';
        $request = $this->getModelsRequest($id, $category, $category_like, $category_not_equals, $name, $name_like, $key, $deployment_id, $version, $latest_version, $deployed, $tenant_id, $tenant_id_like, $without_tenant_id, $sort);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getModels'
     *
     * @param  string $id Only return models with the given version. (optional)
     * @param  string $category Only return models with the given category. (optional)
     * @param  string $category_like Only return models with a category like the given name. (optional)
     * @param  string $category_not_equals Only return models which don�t have the given category. (optional)
     * @param  string $name Only return models with the given name. (optional)
     * @param  string $name_like Only return models with a name like the given name. (optional)
     * @param  string $key Only return models with the given key. (optional)
     * @param  string $deployment_id Only return models with the given category. (optional)
     * @param  int $version Only return models with the given version. (optional)
     * @param  bool $latest_version If true, only return models which are the latest version. Best used in combination with key. If false is passed in as value, this is ignored and all versions are returned. (optional)
     * @param  bool $deployed If true, only deployed models are returned. If false, only undeployed models are returned (deploymentId is null). (optional)
     * @param  string $tenant_id Only return models with the given tenantId. (optional)
     * @param  string $tenant_id_like Only return models with a tenantId like the given value. (optional)
     * @param  bool $without_tenant_id If true, only returns models without a tenantId set. If false, the withoutTenantId parameter is ignored. (optional)
     * @param  string $sort Property to sort on, to be used together with the order. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getModelsRequest($id = null, $category = null, $category_like = null, $category_not_equals = null, $name = null, $name_like = null, $key = null, $deployment_id = null, $version = null, $latest_version = null, $deployed = null, $tenant_id = null, $tenant_id_like = null, $without_tenant_id = null, $sort = null)
    {

        $resourcePath = '/repository/models';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($id !== null) {
            $queryParams['id'] = ObjectSerializer::toQueryValue($id);
        }
        // query params
        if ($category !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($category);
        }
        // query params
        if ($category_like !== null) {
            $queryParams['categoryLike'] = ObjectSerializer::toQueryValue($category_like);
        }
        // query params
        if ($category_not_equals !== null) {
            $queryParams['categoryNotEquals'] = ObjectSerializer::toQueryValue($category_not_equals);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($name_like !== null) {
            $queryParams['nameLike'] = ObjectSerializer::toQueryValue($name_like);
        }
        // query params
        if ($key !== null) {
            $queryParams['key'] = ObjectSerializer::toQueryValue($key);
        }
        // query params
        if ($deployment_id !== null) {
            $queryParams['deploymentId'] = ObjectSerializer::toQueryValue($deployment_id);
        }
        // query params
        if ($version !== null) {
            $queryParams['version'] = ObjectSerializer::toQueryValue($version);
        }
        // query params
        if ($latest_version !== null) {
            $queryParams['latestVersion'] = ObjectSerializer::toQueryValue($latest_version);
        }
        // query params
        if ($deployed !== null) {
            $queryParams['deployed'] = ObjectSerializer::toQueryValue($deployed);
        }
        // query params
        if ($tenant_id !== null) {
            $queryParams['tenantId'] = ObjectSerializer::toQueryValue($tenant_id);
        }
        // query params
        if ($tenant_id_like !== null) {
            $queryParams['tenantIdLike'] = ObjectSerializer::toQueryValue($tenant_id_like);
        }
        // query params
        if ($without_tenant_id !== null) {
            $queryParams['withoutTenantId'] = ObjectSerializer::toQueryValue($without_tenant_id);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateModel
     *
     * Update a model
     *
     * @param  string $model_id model_id (required)
     * @param  \Swagger\Client\Model\ModelRequest $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ModelResponse
     */
    public function updateModel($model_id, $body = null)
    {
        list($response) = $this->updateModelWithHttpInfo($model_id, $body);
        return $response;
    }

    /**
     * Operation updateModelWithHttpInfo
     *
     * Update a model
     *
     * @param  string $model_id (required)
     * @param  \Swagger\Client\Model\ModelRequest $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ModelResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateModelWithHttpInfo($model_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\ModelResponse';
        $request = $this->updateModelRequest($model_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ModelResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateModelAsync
     *
     * Update a model
     *
     * @param  string $model_id (required)
     * @param  \Swagger\Client\Model\ModelRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateModelAsync($model_id, $body = null)
    {
        return $this->updateModelAsyncWithHttpInfo($model_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateModelAsyncWithHttpInfo
     *
     * Update a model
     *
     * @param  string $model_id (required)
     * @param  \Swagger\Client\Model\ModelRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateModelAsyncWithHttpInfo($model_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\ModelResponse';
        $request = $this->updateModelRequest($model_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateModel'
     *
     * @param  string $model_id (required)
     * @param  \Swagger\Client\Model\ModelRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateModelRequest($model_id, $body = null)
    {
        // verify the required parameter 'model_id' is set
        if ($model_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $model_id when calling updateModel'
            );
        }

        $resourcePath = '/repository/models/{modelId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($model_id !== null) {
            $resourcePath = str_replace(
                '{' . 'modelId' . '}',
                ObjectSerializer::toPathValue($model_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
