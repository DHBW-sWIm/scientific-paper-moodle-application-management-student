<?php
/**
 * TasksApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   http://github.com/swagger-api/swagger-codegen
 * @license  http://www.apache.org/licenses/LICENSE-2.0 Apache License v2
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * sWIm Activiti REST API
 *
 * here be dragons
 *
 * OpenAPI spec version: v0.2.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * TasksApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   http://github.com/swagger-api/swagger-codegen
 * @license  http://www.apache.org/licenses/LICENSE-2.0 Apache License v2
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class TasksApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation createAttachment
     *
     * Create a new attachment on a task, containing a link to an external resource or an attached file
     *
     * @param  string $task_id The id of the task to create the attachment for. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\AttachmentResponse
     */
    public function createAttachment($task_id)
    {
        list($response) = $this->createAttachmentWithHttpInfo($task_id);
        return $response;
    }

    /**
     * Operation createAttachmentWithHttpInfo
     *
     * Create a new attachment on a task, containing a link to an external resource or an attached file
     *
     * @param  string $task_id The id of the task to create the attachment for. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\AttachmentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createAttachmentWithHttpInfo($task_id)
    {
        $returnType = '\Swagger\Client\Model\AttachmentResponse';
        $request = $this->createAttachmentRequest($task_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\AttachmentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createAttachmentAsync
     *
     * Create a new attachment on a task, containing a link to an external resource or an attached file
     *
     * @param  string $task_id The id of the task to create the attachment for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAttachmentAsync($task_id)
    {
        return $this->createAttachmentAsyncWithHttpInfo($task_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createAttachmentAsyncWithHttpInfo
     *
     * Create a new attachment on a task, containing a link to an external resource or an attached file
     *
     * @param  string $task_id The id of the task to create the attachment for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAttachmentAsyncWithHttpInfo($task_id)
    {
        $returnType = '\Swagger\Client\Model\AttachmentResponse';
        $request = $this->createAttachmentRequest($task_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createAttachment'
     *
     * @param  string $task_id The id of the task to create the attachment for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createAttachmentRequest($task_id)
    {
        // verify the required parameter 'task_id' is set
        if ($task_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_id when calling createAttachment'
            );
        }

        $resourcePath = '/runtime/tasks/{taskId}/attachments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($task_id !== null) {
            $resourcePath = str_replace(
                '{' . 'taskId' . '}',
                ObjectSerializer::toPathValue($task_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createTask
     *
     * Create Task
     *
     * @param  \Swagger\Client\Model\TaskRequest $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\TaskResponse
     */
    public function createTask($body = null)
    {
        list($response) = $this->createTaskWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation createTaskWithHttpInfo
     *
     * Create Task
     *
     * @param  \Swagger\Client\Model\TaskRequest $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\TaskResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createTaskWithHttpInfo($body = null)
    {
        $returnType = '\Swagger\Client\Model\TaskResponse';
        $request = $this->createTaskRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\TaskResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createTaskAsync
     *
     * Create Task
     *
     * @param  \Swagger\Client\Model\TaskRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTaskAsync($body = null)
    {
        return $this->createTaskAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createTaskAsyncWithHttpInfo
     *
     * Create Task
     *
     * @param  \Swagger\Client\Model\TaskRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTaskAsyncWithHttpInfo($body = null)
    {
        $returnType = '\Swagger\Client\Model\TaskResponse';
        $request = $this->createTaskRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createTask'
     *
     * @param  \Swagger\Client\Model\TaskRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createTaskRequest($body = null)
    {

        $resourcePath = '/runtime/tasks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createTaskComments
     *
     * Create a new comment on a task
     *
     * @param  string $task_id The id of the task to create the comment for. (required)
     * @param  \Swagger\Client\Model\CommentRequest $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\CommentResponse
     */
    public function createTaskComments($task_id, $body = null)
    {
        list($response) = $this->createTaskCommentsWithHttpInfo($task_id, $body);
        return $response;
    }

    /**
     * Operation createTaskCommentsWithHttpInfo
     *
     * Create a new comment on a task
     *
     * @param  string $task_id The id of the task to create the comment for. (required)
     * @param  \Swagger\Client\Model\CommentRequest $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\CommentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createTaskCommentsWithHttpInfo($task_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\CommentResponse';
        $request = $this->createTaskCommentsRequest($task_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\CommentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createTaskCommentsAsync
     *
     * Create a new comment on a task
     *
     * @param  string $task_id The id of the task to create the comment for. (required)
     * @param  \Swagger\Client\Model\CommentRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTaskCommentsAsync($task_id, $body = null)
    {
        return $this->createTaskCommentsAsyncWithHttpInfo($task_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createTaskCommentsAsyncWithHttpInfo
     *
     * Create a new comment on a task
     *
     * @param  string $task_id The id of the task to create the comment for. (required)
     * @param  \Swagger\Client\Model\CommentRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTaskCommentsAsyncWithHttpInfo($task_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\CommentResponse';
        $request = $this->createTaskCommentsRequest($task_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createTaskComments'
     *
     * @param  string $task_id The id of the task to create the comment for. (required)
     * @param  \Swagger\Client\Model\CommentRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createTaskCommentsRequest($task_id, $body = null)
    {
        // verify the required parameter 'task_id' is set
        if ($task_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_id when calling createTaskComments'
            );
        }

        $resourcePath = '/runtime/tasks/{taskId}/comments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($task_id !== null) {
            $resourcePath = str_replace(
                '{' . 'taskId' . '}',
                ObjectSerializer::toPathValue($task_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createTaskInstanceIdentityLinks
     *
     * Create an identity link on a task
     *
     * @param  string $task_id The id of the task . (required)
     * @param  \Swagger\Client\Model\RestIdentityLink $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\RestIdentityLink
     */
    public function createTaskInstanceIdentityLinks($task_id, $body = null)
    {
        list($response) = $this->createTaskInstanceIdentityLinksWithHttpInfo($task_id, $body);
        return $response;
    }

    /**
     * Operation createTaskInstanceIdentityLinksWithHttpInfo
     *
     * Create an identity link on a task
     *
     * @param  string $task_id The id of the task . (required)
     * @param  \Swagger\Client\Model\RestIdentityLink $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\RestIdentityLink, HTTP status code, HTTP response headers (array of strings)
     */
    public function createTaskInstanceIdentityLinksWithHttpInfo($task_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\RestIdentityLink';
        $request = $this->createTaskInstanceIdentityLinksRequest($task_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\RestIdentityLink',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createTaskInstanceIdentityLinksAsync
     *
     * Create an identity link on a task
     *
     * @param  string $task_id The id of the task . (required)
     * @param  \Swagger\Client\Model\RestIdentityLink $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTaskInstanceIdentityLinksAsync($task_id, $body = null)
    {
        return $this->createTaskInstanceIdentityLinksAsyncWithHttpInfo($task_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createTaskInstanceIdentityLinksAsyncWithHttpInfo
     *
     * Create an identity link on a task
     *
     * @param  string $task_id The id of the task . (required)
     * @param  \Swagger\Client\Model\RestIdentityLink $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTaskInstanceIdentityLinksAsyncWithHttpInfo($task_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\RestIdentityLink';
        $request = $this->createTaskInstanceIdentityLinksRequest($task_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createTaskInstanceIdentityLinks'
     *
     * @param  string $task_id The id of the task . (required)
     * @param  \Swagger\Client\Model\RestIdentityLink $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createTaskInstanceIdentityLinksRequest($task_id, $body = null)
    {
        // verify the required parameter 'task_id' is set
        if ($task_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_id when calling createTaskInstanceIdentityLinks'
            );
        }

        $resourcePath = '/runtime/tasks/{taskId}/identitylinks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($task_id !== null) {
            $resourcePath = str_replace(
                '{' . 'taskId' . '}',
                ObjectSerializer::toPathValue($task_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createTaskVariable
     *
     * Create new variables on a task
     *
     * @param  string $task_id The id of the task to create the new variable for. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function createTaskVariable($task_id)
    {
        list($response) = $this->createTaskVariableWithHttpInfo($task_id);
        return $response;
    }

    /**
     * Operation createTaskVariableWithHttpInfo
     *
     * Create new variables on a task
     *
     * @param  string $task_id The id of the task to create the new variable for. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function createTaskVariableWithHttpInfo($task_id)
    {
        $returnType = 'object';
        $request = $this->createTaskVariableRequest($task_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createTaskVariableAsync
     *
     * Create new variables on a task
     *
     * @param  string $task_id The id of the task to create the new variable for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTaskVariableAsync($task_id)
    {
        return $this->createTaskVariableAsyncWithHttpInfo($task_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createTaskVariableAsyncWithHttpInfo
     *
     * Create new variables on a task
     *
     * @param  string $task_id The id of the task to create the new variable for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTaskVariableAsyncWithHttpInfo($task_id)
    {
        $returnType = 'object';
        $request = $this->createTaskVariableRequest($task_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createTaskVariable'
     *
     * @param  string $task_id The id of the task to create the new variable for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createTaskVariableRequest($task_id)
    {
        // verify the required parameter 'task_id' is set
        if ($task_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_id when calling createTaskVariable'
            );
        }

        $resourcePath = '/runtime/tasks/{taskId}/variables';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($task_id !== null) {
            $resourcePath = str_replace(
                '{' . 'taskId' . '}',
                ObjectSerializer::toPathValue($task_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteAllLocalTaskVariables
     *
     * Delete all local variables on a task
     *
     * @param  string $task_id The id of the task the variable to delete belongs to. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteAllLocalTaskVariables($task_id)
    {
        $this->deleteAllLocalTaskVariablesWithHttpInfo($task_id);
    }

    /**
     * Operation deleteAllLocalTaskVariablesWithHttpInfo
     *
     * Delete all local variables on a task
     *
     * @param  string $task_id The id of the task the variable to delete belongs to. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteAllLocalTaskVariablesWithHttpInfo($task_id)
    {
        $returnType = '';
        $request = $this->deleteAllLocalTaskVariablesRequest($task_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteAllLocalTaskVariablesAsync
     *
     * Delete all local variables on a task
     *
     * @param  string $task_id The id of the task the variable to delete belongs to. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAllLocalTaskVariablesAsync($task_id)
    {
        return $this->deleteAllLocalTaskVariablesAsyncWithHttpInfo($task_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteAllLocalTaskVariablesAsyncWithHttpInfo
     *
     * Delete all local variables on a task
     *
     * @param  string $task_id The id of the task the variable to delete belongs to. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAllLocalTaskVariablesAsyncWithHttpInfo($task_id)
    {
        $returnType = '';
        $request = $this->deleteAllLocalTaskVariablesRequest($task_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteAllLocalTaskVariables'
     *
     * @param  string $task_id The id of the task the variable to delete belongs to. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteAllLocalTaskVariablesRequest($task_id)
    {
        // verify the required parameter 'task_id' is set
        if ($task_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_id when calling deleteAllLocalTaskVariables'
            );
        }

        $resourcePath = '/runtime/tasks/{taskId}/variables';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($task_id !== null) {
            $resourcePath = str_replace(
                '{' . 'taskId' . '}',
                ObjectSerializer::toPathValue($task_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteAttachment
     *
     * Delete an attachment on a task
     *
     * @param  string $task_id The id of the task to delete the attachment for. (required)
     * @param  string $attachment_id The id of the attachment. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteAttachment($task_id, $attachment_id)
    {
        $this->deleteAttachmentWithHttpInfo($task_id, $attachment_id);
    }

    /**
     * Operation deleteAttachmentWithHttpInfo
     *
     * Delete an attachment on a task
     *
     * @param  string $task_id The id of the task to delete the attachment for. (required)
     * @param  string $attachment_id The id of the attachment. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteAttachmentWithHttpInfo($task_id, $attachment_id)
    {
        $returnType = '';
        $request = $this->deleteAttachmentRequest($task_id, $attachment_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteAttachmentAsync
     *
     * Delete an attachment on a task
     *
     * @param  string $task_id The id of the task to delete the attachment for. (required)
     * @param  string $attachment_id The id of the attachment. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAttachmentAsync($task_id, $attachment_id)
    {
        return $this->deleteAttachmentAsyncWithHttpInfo($task_id, $attachment_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteAttachmentAsyncWithHttpInfo
     *
     * Delete an attachment on a task
     *
     * @param  string $task_id The id of the task to delete the attachment for. (required)
     * @param  string $attachment_id The id of the attachment. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAttachmentAsyncWithHttpInfo($task_id, $attachment_id)
    {
        $returnType = '';
        $request = $this->deleteAttachmentRequest($task_id, $attachment_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteAttachment'
     *
     * @param  string $task_id The id of the task to delete the attachment for. (required)
     * @param  string $attachment_id The id of the attachment. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteAttachmentRequest($task_id, $attachment_id)
    {
        // verify the required parameter 'task_id' is set
        if ($task_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_id when calling deleteAttachment'
            );
        }
        // verify the required parameter 'attachment_id' is set
        if ($attachment_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attachment_id when calling deleteAttachment'
            );
        }

        $resourcePath = '/runtime/tasks/{taskId}/attachments/{attachmentId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($task_id !== null) {
            $resourcePath = str_replace(
                '{' . 'taskId' . '}',
                ObjectSerializer::toPathValue($task_id),
                $resourcePath
            );
        }
        // path params
        if ($attachment_id !== null) {
            $resourcePath = str_replace(
                '{' . 'attachmentId' . '}',
                ObjectSerializer::toPathValue($attachment_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteEvent
     *
     * Delete an event on a task
     *
     * @param  string $task_id task_id (required)
     * @param  string $event_id event_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteEvent($task_id, $event_id)
    {
        $this->deleteEventWithHttpInfo($task_id, $event_id);
    }

    /**
     * Operation deleteEventWithHttpInfo
     *
     * Delete an event on a task
     *
     * @param  string $task_id (required)
     * @param  string $event_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteEventWithHttpInfo($task_id, $event_id)
    {
        $returnType = '';
        $request = $this->deleteEventRequest($task_id, $event_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteEventAsync
     *
     * Delete an event on a task
     *
     * @param  string $task_id (required)
     * @param  string $event_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteEventAsync($task_id, $event_id)
    {
        return $this->deleteEventAsyncWithHttpInfo($task_id, $event_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteEventAsyncWithHttpInfo
     *
     * Delete an event on a task
     *
     * @param  string $task_id (required)
     * @param  string $event_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteEventAsyncWithHttpInfo($task_id, $event_id)
    {
        $returnType = '';
        $request = $this->deleteEventRequest($task_id, $event_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteEvent'
     *
     * @param  string $task_id (required)
     * @param  string $event_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteEventRequest($task_id, $event_id)
    {
        // verify the required parameter 'task_id' is set
        if ($task_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_id when calling deleteEvent'
            );
        }
        // verify the required parameter 'event_id' is set
        if ($event_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $event_id when calling deleteEvent'
            );
        }

        $resourcePath = '/runtime/tasks/{taskId}/events/{eventId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($task_id !== null) {
            $resourcePath = str_replace(
                '{' . 'taskId' . '}',
                ObjectSerializer::toPathValue($task_id),
                $resourcePath
            );
        }
        // path params
        if ($event_id !== null) {
            $resourcePath = str_replace(
                '{' . 'eventId' . '}',
                ObjectSerializer::toPathValue($event_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteTask
     *
     * Delete a task
     *
     * @param  string $task_id The id of the task to delete. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteTask($task_id)
    {
        $this->deleteTaskWithHttpInfo($task_id);
    }

    /**
     * Operation deleteTaskWithHttpInfo
     *
     * Delete a task
     *
     * @param  string $task_id The id of the task to delete. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteTaskWithHttpInfo($task_id)
    {
        $returnType = '';
        $request = $this->deleteTaskRequest($task_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteTaskAsync
     *
     * Delete a task
     *
     * @param  string $task_id The id of the task to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTaskAsync($task_id)
    {
        return $this->deleteTaskAsyncWithHttpInfo($task_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteTaskAsyncWithHttpInfo
     *
     * Delete a task
     *
     * @param  string $task_id The id of the task to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTaskAsyncWithHttpInfo($task_id)
    {
        $returnType = '';
        $request = $this->deleteTaskRequest($task_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteTask'
     *
     * @param  string $task_id The id of the task to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteTaskRequest($task_id)
    {
        // verify the required parameter 'task_id' is set
        if ($task_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_id when calling deleteTask'
            );
        }

        $resourcePath = '/runtime/tasks/{taskId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($task_id !== null) {
            $resourcePath = str_replace(
                '{' . 'taskId' . '}',
                ObjectSerializer::toPathValue($task_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteTaskComment
     *
     * Delete a comment on a task
     *
     * @param  string $task_id The id of the task to delete the comment for. (required)
     * @param  string $comment_id The id of the comment. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteTaskComment($task_id, $comment_id)
    {
        $this->deleteTaskCommentWithHttpInfo($task_id, $comment_id);
    }

    /**
     * Operation deleteTaskCommentWithHttpInfo
     *
     * Delete a comment on a task
     *
     * @param  string $task_id The id of the task to delete the comment for. (required)
     * @param  string $comment_id The id of the comment. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteTaskCommentWithHttpInfo($task_id, $comment_id)
    {
        $returnType = '';
        $request = $this->deleteTaskCommentRequest($task_id, $comment_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteTaskCommentAsync
     *
     * Delete a comment on a task
     *
     * @param  string $task_id The id of the task to delete the comment for. (required)
     * @param  string $comment_id The id of the comment. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTaskCommentAsync($task_id, $comment_id)
    {
        return $this->deleteTaskCommentAsyncWithHttpInfo($task_id, $comment_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteTaskCommentAsyncWithHttpInfo
     *
     * Delete a comment on a task
     *
     * @param  string $task_id The id of the task to delete the comment for. (required)
     * @param  string $comment_id The id of the comment. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTaskCommentAsyncWithHttpInfo($task_id, $comment_id)
    {
        $returnType = '';
        $request = $this->deleteTaskCommentRequest($task_id, $comment_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteTaskComment'
     *
     * @param  string $task_id The id of the task to delete the comment for. (required)
     * @param  string $comment_id The id of the comment. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteTaskCommentRequest($task_id, $comment_id)
    {
        // verify the required parameter 'task_id' is set
        if ($task_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_id when calling deleteTaskComment'
            );
        }
        // verify the required parameter 'comment_id' is set
        if ($comment_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $comment_id when calling deleteTaskComment'
            );
        }

        $resourcePath = '/runtime/tasks/{taskId}/comments/{commentId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($task_id !== null) {
            $resourcePath = str_replace(
                '{' . 'taskId' . '}',
                ObjectSerializer::toPathValue($task_id),
                $resourcePath
            );
        }
        // path params
        if ($comment_id !== null) {
            $resourcePath = str_replace(
                '{' . 'commentId' . '}',
                ObjectSerializer::toPathValue($comment_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteTaskInstanceIdentityLinks
     *
     * Delete an identity link on a task
     *
     * @param  string $task_id The id of the task. (required)
     * @param  string $family Either groups or users, depending on what kind of identity is targeted. (required)
     * @param  string $identity_id The id of the identity. (required)
     * @param  string $type The type of identity link. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteTaskInstanceIdentityLinks($task_id, $family, $identity_id, $type)
    {
        $this->deleteTaskInstanceIdentityLinksWithHttpInfo($task_id, $family, $identity_id, $type);
    }

    /**
     * Operation deleteTaskInstanceIdentityLinksWithHttpInfo
     *
     * Delete an identity link on a task
     *
     * @param  string $task_id The id of the task. (required)
     * @param  string $family Either groups or users, depending on what kind of identity is targeted. (required)
     * @param  string $identity_id The id of the identity. (required)
     * @param  string $type The type of identity link. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteTaskInstanceIdentityLinksWithHttpInfo($task_id, $family, $identity_id, $type)
    {
        $returnType = '';
        $request = $this->deleteTaskInstanceIdentityLinksRequest($task_id, $family, $identity_id, $type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteTaskInstanceIdentityLinksAsync
     *
     * Delete an identity link on a task
     *
     * @param  string $task_id The id of the task. (required)
     * @param  string $family Either groups or users, depending on what kind of identity is targeted. (required)
     * @param  string $identity_id The id of the identity. (required)
     * @param  string $type The type of identity link. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTaskInstanceIdentityLinksAsync($task_id, $family, $identity_id, $type)
    {
        return $this->deleteTaskInstanceIdentityLinksAsyncWithHttpInfo($task_id, $family, $identity_id, $type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteTaskInstanceIdentityLinksAsyncWithHttpInfo
     *
     * Delete an identity link on a task
     *
     * @param  string $task_id The id of the task. (required)
     * @param  string $family Either groups or users, depending on what kind of identity is targeted. (required)
     * @param  string $identity_id The id of the identity. (required)
     * @param  string $type The type of identity link. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTaskInstanceIdentityLinksAsyncWithHttpInfo($task_id, $family, $identity_id, $type)
    {
        $returnType = '';
        $request = $this->deleteTaskInstanceIdentityLinksRequest($task_id, $family, $identity_id, $type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteTaskInstanceIdentityLinks'
     *
     * @param  string $task_id The id of the task. (required)
     * @param  string $family Either groups or users, depending on what kind of identity is targeted. (required)
     * @param  string $identity_id The id of the identity. (required)
     * @param  string $type The type of identity link. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteTaskInstanceIdentityLinksRequest($task_id, $family, $identity_id, $type)
    {
        // verify the required parameter 'task_id' is set
        if ($task_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_id when calling deleteTaskInstanceIdentityLinks'
            );
        }
        // verify the required parameter 'family' is set
        if ($family === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $family when calling deleteTaskInstanceIdentityLinks'
            );
        }
        // verify the required parameter 'identity_id' is set
        if ($identity_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $identity_id when calling deleteTaskInstanceIdentityLinks'
            );
        }
        // verify the required parameter 'type' is set
        if ($type === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling deleteTaskInstanceIdentityLinks'
            );
        }

        $resourcePath = '/runtime/tasks/{taskId}/identitylinks/{family}/{identityId}/{type}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($task_id !== null) {
            $resourcePath = str_replace(
                '{' . 'taskId' . '}',
                ObjectSerializer::toPathValue($task_id),
                $resourcePath
            );
        }
        // path params
        if ($family !== null) {
            $resourcePath = str_replace(
                '{' . 'family' . '}',
                ObjectSerializer::toPathValue($family),
                $resourcePath
            );
        }
        // path params
        if ($identity_id !== null) {
            $resourcePath = str_replace(
                '{' . 'identityId' . '}',
                ObjectSerializer::toPathValue($identity_id),
                $resourcePath
            );
        }
        // path params
        if ($type !== null) {
            $resourcePath = str_replace(
                '{' . 'type' . '}',
                ObjectSerializer::toPathValue($type),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteTaskInstanceVariable
     *
     * Delete a variable on a task
     *
     * @param  string $task_id The id of the task the variable to delete belongs to. (required)
     * @param  string $variable_name The name of the variable to delete. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteTaskInstanceVariable($task_id, $variable_name)
    {
        $this->deleteTaskInstanceVariableWithHttpInfo($task_id, $variable_name);
    }

    /**
     * Operation deleteTaskInstanceVariableWithHttpInfo
     *
     * Delete a variable on a task
     *
     * @param  string $task_id The id of the task the variable to delete belongs to. (required)
     * @param  string $variable_name The name of the variable to delete. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteTaskInstanceVariableWithHttpInfo($task_id, $variable_name)
    {
        $returnType = '';
        $request = $this->deleteTaskInstanceVariableRequest($task_id, $variable_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteTaskInstanceVariableAsync
     *
     * Delete a variable on a task
     *
     * @param  string $task_id The id of the task the variable to delete belongs to. (required)
     * @param  string $variable_name The name of the variable to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTaskInstanceVariableAsync($task_id, $variable_name)
    {
        return $this->deleteTaskInstanceVariableAsyncWithHttpInfo($task_id, $variable_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteTaskInstanceVariableAsyncWithHttpInfo
     *
     * Delete a variable on a task
     *
     * @param  string $task_id The id of the task the variable to delete belongs to. (required)
     * @param  string $variable_name The name of the variable to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTaskInstanceVariableAsyncWithHttpInfo($task_id, $variable_name)
    {
        $returnType = '';
        $request = $this->deleteTaskInstanceVariableRequest($task_id, $variable_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteTaskInstanceVariable'
     *
     * @param  string $task_id The id of the task the variable to delete belongs to. (required)
     * @param  string $variable_name The name of the variable to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteTaskInstanceVariableRequest($task_id, $variable_name)
    {
        // verify the required parameter 'task_id' is set
        if ($task_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_id when calling deleteTaskInstanceVariable'
            );
        }
        // verify the required parameter 'variable_name' is set
        if ($variable_name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $variable_name when calling deleteTaskInstanceVariable'
            );
        }

        $resourcePath = '/runtime/tasks/{taskId}/variables/{variableName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($task_id !== null) {
            $resourcePath = str_replace(
                '{' . 'taskId' . '}',
                ObjectSerializer::toPathValue($task_id),
                $resourcePath
            );
        }
        // path params
        if ($variable_name !== null) {
            $resourcePath = str_replace(
                '{' . 'variableName' . '}',
                ObjectSerializer::toPathValue($variable_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation executeTaskAction
     *
     * Tasks actions
     *
     * @param  string $task_id task_id (required)
     * @param  \Swagger\Client\Model\TaskActionRequest $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function executeTaskAction($task_id, $body = null)
    {
        $this->executeTaskActionWithHttpInfo($task_id, $body);
    }

    /**
     * Operation executeTaskActionWithHttpInfo
     *
     * Tasks actions
     *
     * @param  string $task_id (required)
     * @param  \Swagger\Client\Model\TaskActionRequest $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function executeTaskActionWithHttpInfo($task_id, $body = null)
    {
        $returnType = '';
        $request = $this->executeTaskActionRequest($task_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation executeTaskActionAsync
     *
     * Tasks actions
     *
     * @param  string $task_id (required)
     * @param  \Swagger\Client\Model\TaskActionRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function executeTaskActionAsync($task_id, $body = null)
    {
        return $this->executeTaskActionAsyncWithHttpInfo($task_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation executeTaskActionAsyncWithHttpInfo
     *
     * Tasks actions
     *
     * @param  string $task_id (required)
     * @param  \Swagger\Client\Model\TaskActionRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function executeTaskActionAsyncWithHttpInfo($task_id, $body = null)
    {
        $returnType = '';
        $request = $this->executeTaskActionRequest($task_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'executeTaskAction'
     *
     * @param  string $task_id (required)
     * @param  \Swagger\Client\Model\TaskActionRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function executeTaskActionRequest($task_id, $body = null)
    {
        // verify the required parameter 'task_id' is set
        if ($task_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_id when calling executeTaskAction'
            );
        }

        $resourcePath = '/runtime/tasks/{taskId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($task_id !== null) {
            $resourcePath = str_replace(
                '{' . 'taskId' . '}',
                ObjectSerializer::toPathValue($task_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation geTaskVariableData
     *
     * Get the binary data for a variable
     *
     * @param  string $task_id The id of the task to get a variable data for. (required)
     * @param  string $variable_name The name of the variable to get data for. Only variables of type binary and serializable can be used. If any other type of variable is used, a 404 is returned. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string[]
     */
    public function geTaskVariableData($task_id, $variable_name)
    {
        list($response) = $this->geTaskVariableDataWithHttpInfo($task_id, $variable_name);
        return $response;
    }

    /**
     * Operation geTaskVariableDataWithHttpInfo
     *
     * Get the binary data for a variable
     *
     * @param  string $task_id The id of the task to get a variable data for. (required)
     * @param  string $variable_name The name of the variable to get data for. Only variables of type binary and serializable can be used. If any other type of variable is used, a 404 is returned. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string[], HTTP status code, HTTP response headers (array of strings)
     */
    public function geTaskVariableDataWithHttpInfo($task_id, $variable_name)
    {
        $returnType = 'string[]';
        $request = $this->geTaskVariableDataRequest($task_id, $variable_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation geTaskVariableDataAsync
     *
     * Get the binary data for a variable
     *
     * @param  string $task_id The id of the task to get a variable data for. (required)
     * @param  string $variable_name The name of the variable to get data for. Only variables of type binary and serializable can be used. If any other type of variable is used, a 404 is returned. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function geTaskVariableDataAsync($task_id, $variable_name)
    {
        return $this->geTaskVariableDataAsyncWithHttpInfo($task_id, $variable_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation geTaskVariableDataAsyncWithHttpInfo
     *
     * Get the binary data for a variable
     *
     * @param  string $task_id The id of the task to get a variable data for. (required)
     * @param  string $variable_name The name of the variable to get data for. Only variables of type binary and serializable can be used. If any other type of variable is used, a 404 is returned. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function geTaskVariableDataAsyncWithHttpInfo($task_id, $variable_name)
    {
        $returnType = 'string[]';
        $request = $this->geTaskVariableDataRequest($task_id, $variable_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'geTaskVariableData'
     *
     * @param  string $task_id The id of the task to get a variable data for. (required)
     * @param  string $variable_name The name of the variable to get data for. Only variables of type binary and serializable can be used. If any other type of variable is used, a 404 is returned. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function geTaskVariableDataRequest($task_id, $variable_name)
    {
        // verify the required parameter 'task_id' is set
        if ($task_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_id when calling geTaskVariableData'
            );
        }
        // verify the required parameter 'variable_name' is set
        if ($variable_name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $variable_name when calling geTaskVariableData'
            );
        }

        $resourcePath = '/runtime/tasks/{taskId}/variables/{variableName}/data';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($task_id !== null) {
            $resourcePath = str_replace(
                '{' . 'taskId' . '}',
                ObjectSerializer::toPathValue($task_id),
                $resourcePath
            );
        }
        // path params
        if ($variable_name !== null) {
            $resourcePath = str_replace(
                '{' . 'variableName' . '}',
                ObjectSerializer::toPathValue($variable_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAttachment
     *
     * Get an attachment on a task
     *
     * @param  string $task_id The id of the task to get the attachment for. (required)
     * @param  string $attachment_id The id of the attachment. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\AttachmentResponse
     */
    public function getAttachment($task_id, $attachment_id)
    {
        list($response) = $this->getAttachmentWithHttpInfo($task_id, $attachment_id);
        return $response;
    }

    /**
     * Operation getAttachmentWithHttpInfo
     *
     * Get an attachment on a task
     *
     * @param  string $task_id The id of the task to get the attachment for. (required)
     * @param  string $attachment_id The id of the attachment. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\AttachmentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAttachmentWithHttpInfo($task_id, $attachment_id)
    {
        $returnType = '\Swagger\Client\Model\AttachmentResponse';
        $request = $this->getAttachmentRequest($task_id, $attachment_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\AttachmentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAttachmentAsync
     *
     * Get an attachment on a task
     *
     * @param  string $task_id The id of the task to get the attachment for. (required)
     * @param  string $attachment_id The id of the attachment. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAttachmentAsync($task_id, $attachment_id)
    {
        return $this->getAttachmentAsyncWithHttpInfo($task_id, $attachment_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAttachmentAsyncWithHttpInfo
     *
     * Get an attachment on a task
     *
     * @param  string $task_id The id of the task to get the attachment for. (required)
     * @param  string $attachment_id The id of the attachment. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAttachmentAsyncWithHttpInfo($task_id, $attachment_id)
    {
        $returnType = '\Swagger\Client\Model\AttachmentResponse';
        $request = $this->getAttachmentRequest($task_id, $attachment_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAttachment'
     *
     * @param  string $task_id The id of the task to get the attachment for. (required)
     * @param  string $attachment_id The id of the attachment. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAttachmentRequest($task_id, $attachment_id)
    {
        // verify the required parameter 'task_id' is set
        if ($task_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_id when calling getAttachment'
            );
        }
        // verify the required parameter 'attachment_id' is set
        if ($attachment_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attachment_id when calling getAttachment'
            );
        }

        $resourcePath = '/runtime/tasks/{taskId}/attachments/{attachmentId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($task_id !== null) {
            $resourcePath = str_replace(
                '{' . 'taskId' . '}',
                ObjectSerializer::toPathValue($task_id),
                $resourcePath
            );
        }
        // path params
        if ($attachment_id !== null) {
            $resourcePath = str_replace(
                '{' . 'attachmentId' . '}',
                ObjectSerializer::toPathValue($attachment_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAttachmentContent
     *
     * Get the content for an attachment
     *
     * @param  string $task_id The id of the task to get a variable data for. (required)
     * @param  string $attachment_id The id of the attachment, a 404 is returned when the attachment points to an external URL rather than content attached in Activiti. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string[]
     */
    public function getAttachmentContent($task_id, $attachment_id)
    {
        list($response) = $this->getAttachmentContentWithHttpInfo($task_id, $attachment_id);
        return $response;
    }

    /**
     * Operation getAttachmentContentWithHttpInfo
     *
     * Get the content for an attachment
     *
     * @param  string $task_id The id of the task to get a variable data for. (required)
     * @param  string $attachment_id The id of the attachment, a 404 is returned when the attachment points to an external URL rather than content attached in Activiti. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getAttachmentContentWithHttpInfo($task_id, $attachment_id)
    {
        $returnType = 'string[]';
        $request = $this->getAttachmentContentRequest($task_id, $attachment_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAttachmentContentAsync
     *
     * Get the content for an attachment
     *
     * @param  string $task_id The id of the task to get a variable data for. (required)
     * @param  string $attachment_id The id of the attachment, a 404 is returned when the attachment points to an external URL rather than content attached in Activiti. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAttachmentContentAsync($task_id, $attachment_id)
    {
        return $this->getAttachmentContentAsyncWithHttpInfo($task_id, $attachment_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAttachmentContentAsyncWithHttpInfo
     *
     * Get the content for an attachment
     *
     * @param  string $task_id The id of the task to get a variable data for. (required)
     * @param  string $attachment_id The id of the attachment, a 404 is returned when the attachment points to an external URL rather than content attached in Activiti. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAttachmentContentAsyncWithHttpInfo($task_id, $attachment_id)
    {
        $returnType = 'string[]';
        $request = $this->getAttachmentContentRequest($task_id, $attachment_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAttachmentContent'
     *
     * @param  string $task_id The id of the task to get a variable data for. (required)
     * @param  string $attachment_id The id of the attachment, a 404 is returned when the attachment points to an external URL rather than content attached in Activiti. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAttachmentContentRequest($task_id, $attachment_id)
    {
        // verify the required parameter 'task_id' is set
        if ($task_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_id when calling getAttachmentContent'
            );
        }
        // verify the required parameter 'attachment_id' is set
        if ($attachment_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attachment_id when calling getAttachmentContent'
            );
        }

        $resourcePath = '/runtime/tasks/{taskId}/attachments/{attachmentId}/content';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($task_id !== null) {
            $resourcePath = str_replace(
                '{' . 'taskId' . '}',
                ObjectSerializer::toPathValue($task_id),
                $resourcePath
            );
        }
        // path params
        if ($attachment_id !== null) {
            $resourcePath = str_replace(
                '{' . 'attachmentId' . '}',
                ObjectSerializer::toPathValue($attachment_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAttachments
     *
     * Get all attachments on a task
     *
     * @param  string $task_id The id of the task to get the attachments for. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\AttachmentResponse[]
     */
    public function getAttachments($task_id)
    {
        list($response) = $this->getAttachmentsWithHttpInfo($task_id);
        return $response;
    }

    /**
     * Operation getAttachmentsWithHttpInfo
     *
     * Get all attachments on a task
     *
     * @param  string $task_id The id of the task to get the attachments for. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\AttachmentResponse[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getAttachmentsWithHttpInfo($task_id)
    {
        $returnType = '\Swagger\Client\Model\AttachmentResponse[]';
        $request = $this->getAttachmentsRequest($task_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\AttachmentResponse[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAttachmentsAsync
     *
     * Get all attachments on a task
     *
     * @param  string $task_id The id of the task to get the attachments for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAttachmentsAsync($task_id)
    {
        return $this->getAttachmentsAsyncWithHttpInfo($task_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAttachmentsAsyncWithHttpInfo
     *
     * Get all attachments on a task
     *
     * @param  string $task_id The id of the task to get the attachments for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAttachmentsAsyncWithHttpInfo($task_id)
    {
        $returnType = '\Swagger\Client\Model\AttachmentResponse[]';
        $request = $this->getAttachmentsRequest($task_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAttachments'
     *
     * @param  string $task_id The id of the task to get the attachments for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAttachmentsRequest($task_id)
    {
        // verify the required parameter 'task_id' is set
        if ($task_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_id when calling getAttachments'
            );
        }

        $resourcePath = '/runtime/tasks/{taskId}/attachments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($task_id !== null) {
            $resourcePath = str_replace(
                '{' . 'taskId' . '}',
                ObjectSerializer::toPathValue($task_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getEvent
     *
     * Get an event on a task
     *
     * @param  string $task_id The id of the task to get the event for. (required)
     * @param  string $event_id The id of the event. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\EventResponse
     */
    public function getEvent($task_id, $event_id)
    {
        list($response) = $this->getEventWithHttpInfo($task_id, $event_id);
        return $response;
    }

    /**
     * Operation getEventWithHttpInfo
     *
     * Get an event on a task
     *
     * @param  string $task_id The id of the task to get the event for. (required)
     * @param  string $event_id The id of the event. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\EventResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getEventWithHttpInfo($task_id, $event_id)
    {
        $returnType = '\Swagger\Client\Model\EventResponse';
        $request = $this->getEventRequest($task_id, $event_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\EventResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getEventAsync
     *
     * Get an event on a task
     *
     * @param  string $task_id The id of the task to get the event for. (required)
     * @param  string $event_id The id of the event. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEventAsync($task_id, $event_id)
    {
        return $this->getEventAsyncWithHttpInfo($task_id, $event_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getEventAsyncWithHttpInfo
     *
     * Get an event on a task
     *
     * @param  string $task_id The id of the task to get the event for. (required)
     * @param  string $event_id The id of the event. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEventAsyncWithHttpInfo($task_id, $event_id)
    {
        $returnType = '\Swagger\Client\Model\EventResponse';
        $request = $this->getEventRequest($task_id, $event_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getEvent'
     *
     * @param  string $task_id The id of the task to get the event for. (required)
     * @param  string $event_id The id of the event. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getEventRequest($task_id, $event_id)
    {
        // verify the required parameter 'task_id' is set
        if ($task_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_id when calling getEvent'
            );
        }
        // verify the required parameter 'event_id' is set
        if ($event_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $event_id when calling getEvent'
            );
        }

        $resourcePath = '/runtime/tasks/{taskId}/events/{eventId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($task_id !== null) {
            $resourcePath = str_replace(
                '{' . 'taskId' . '}',
                ObjectSerializer::toPathValue($task_id),
                $resourcePath
            );
        }
        // path params
        if ($event_id !== null) {
            $resourcePath = str_replace(
                '{' . 'eventId' . '}',
                ObjectSerializer::toPathValue($event_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getEvents
     *
     * Get all events for a task
     *
     * @param  string $task_id The id of the task to get the events for. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\EventResponse[]
     */
    public function getEvents($task_id)
    {
        list($response) = $this->getEventsWithHttpInfo($task_id);
        return $response;
    }

    /**
     * Operation getEventsWithHttpInfo
     *
     * Get all events for a task
     *
     * @param  string $task_id The id of the task to get the events for. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\EventResponse[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getEventsWithHttpInfo($task_id)
    {
        $returnType = '\Swagger\Client\Model\EventResponse[]';
        $request = $this->getEventsRequest($task_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\EventResponse[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getEventsAsync
     *
     * Get all events for a task
     *
     * @param  string $task_id The id of the task to get the events for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEventsAsync($task_id)
    {
        return $this->getEventsAsyncWithHttpInfo($task_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getEventsAsyncWithHttpInfo
     *
     * Get all events for a task
     *
     * @param  string $task_id The id of the task to get the events for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEventsAsyncWithHttpInfo($task_id)
    {
        $returnType = '\Swagger\Client\Model\EventResponse[]';
        $request = $this->getEventsRequest($task_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getEvents'
     *
     * @param  string $task_id The id of the task to get the events for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getEventsRequest($task_id)
    {
        // verify the required parameter 'task_id' is set
        if ($task_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_id when calling getEvents'
            );
        }

        $resourcePath = '/runtime/tasks/{taskId}/events';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($task_id !== null) {
            $resourcePath = str_replace(
                '{' . 'taskId' . '}',
                ObjectSerializer::toPathValue($task_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getIdentityLinksForFamily
     *
     * Get all identitylinks for a task for either groups or users
     *
     * @param  string $task_id task_id (required)
     * @param  string $family family (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\RestIdentityLink[]
     */
    public function getIdentityLinksForFamily($task_id, $family)
    {
        list($response) = $this->getIdentityLinksForFamilyWithHttpInfo($task_id, $family);
        return $response;
    }

    /**
     * Operation getIdentityLinksForFamilyWithHttpInfo
     *
     * Get all identitylinks for a task for either groups or users
     *
     * @param  string $task_id (required)
     * @param  string $family (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\RestIdentityLink[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getIdentityLinksForFamilyWithHttpInfo($task_id, $family)
    {
        $returnType = '\Swagger\Client\Model\RestIdentityLink[]';
        $request = $this->getIdentityLinksForFamilyRequest($task_id, $family);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\RestIdentityLink[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getIdentityLinksForFamilyAsync
     *
     * Get all identitylinks for a task for either groups or users
     *
     * @param  string $task_id (required)
     * @param  string $family (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getIdentityLinksForFamilyAsync($task_id, $family)
    {
        return $this->getIdentityLinksForFamilyAsyncWithHttpInfo($task_id, $family)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getIdentityLinksForFamilyAsyncWithHttpInfo
     *
     * Get all identitylinks for a task for either groups or users
     *
     * @param  string $task_id (required)
     * @param  string $family (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getIdentityLinksForFamilyAsyncWithHttpInfo($task_id, $family)
    {
        $returnType = '\Swagger\Client\Model\RestIdentityLink[]';
        $request = $this->getIdentityLinksForFamilyRequest($task_id, $family);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getIdentityLinksForFamily'
     *
     * @param  string $task_id (required)
     * @param  string $family (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getIdentityLinksForFamilyRequest($task_id, $family)
    {
        // verify the required parameter 'task_id' is set
        if ($task_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_id when calling getIdentityLinksForFamily'
            );
        }
        // verify the required parameter 'family' is set
        if ($family === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $family when calling getIdentityLinksForFamily'
            );
        }

        $resourcePath = '/runtime/tasks/{taskId}/identitylinks/{family}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($task_id !== null) {
            $resourcePath = str_replace(
                '{' . 'taskId' . '}',
                ObjectSerializer::toPathValue($task_id),
                $resourcePath
            );
        }
        // path params
        if ($family !== null) {
            $resourcePath = str_replace(
                '{' . 'family' . '}',
                ObjectSerializer::toPathValue($family),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getQueryResult
     *
     * Query for tasks
     *
     * @param  \Swagger\Client\Model\TaskQueryRequest $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\DataResponse
     */
    public function getQueryResult($body = null)
    {
        list($response) = $this->getQueryResultWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation getQueryResultWithHttpInfo
     *
     * Query for tasks
     *
     * @param  \Swagger\Client\Model\TaskQueryRequest $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\DataResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getQueryResultWithHttpInfo($body = null)
    {
        $returnType = '\Swagger\Client\Model\DataResponse';
        $request = $this->getQueryResultRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\DataResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getQueryResultAsync
     *
     * Query for tasks
     *
     * @param  \Swagger\Client\Model\TaskQueryRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getQueryResultAsync($body = null)
    {
        return $this->getQueryResultAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getQueryResultAsyncWithHttpInfo
     *
     * Query for tasks
     *
     * @param  \Swagger\Client\Model\TaskQueryRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getQueryResultAsyncWithHttpInfo($body = null)
    {
        $returnType = '\Swagger\Client\Model\DataResponse';
        $request = $this->getQueryResultRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getQueryResult'
     *
     * @param  \Swagger\Client\Model\TaskQueryRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getQueryResultRequest($body = null)
    {

        $resourcePath = '/query/tasks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSubTasks
     *
     * Get list of sub tasks for a task
     *
     * @param  string $task_id task_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\TaskResponse[]
     */
    public function getSubTasks($task_id)
    {
        list($response) = $this->getSubTasksWithHttpInfo($task_id);
        return $response;
    }

    /**
     * Operation getSubTasksWithHttpInfo
     *
     * Get list of sub tasks for a task
     *
     * @param  string $task_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\TaskResponse[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getSubTasksWithHttpInfo($task_id)
    {
        $returnType = '\Swagger\Client\Model\TaskResponse[]';
        $request = $this->getSubTasksRequest($task_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\TaskResponse[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSubTasksAsync
     *
     * Get list of sub tasks for a task
     *
     * @param  string $task_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSubTasksAsync($task_id)
    {
        return $this->getSubTasksAsyncWithHttpInfo($task_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSubTasksAsyncWithHttpInfo
     *
     * Get list of sub tasks for a task
     *
     * @param  string $task_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSubTasksAsyncWithHttpInfo($task_id)
    {
        $returnType = '\Swagger\Client\Model\TaskResponse[]';
        $request = $this->getSubTasksRequest($task_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSubTasks'
     *
     * @param  string $task_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getSubTasksRequest($task_id)
    {
        // verify the required parameter 'task_id' is set
        if ($task_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_id when calling getSubTasks'
            );
        }

        $resourcePath = '/runtime/tasks/{taskId}/subtasks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($task_id !== null) {
            $resourcePath = str_replace(
                '{' . 'taskId' . '}',
                ObjectSerializer::toPathValue($task_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTask
     *
     * Get a task
     *
     * @param  string $task_id The id of the task to get. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\TaskResponse
     */
    public function getTask($task_id)
    {
        list($response) = $this->getTaskWithHttpInfo($task_id);
        return $response;
    }

    /**
     * Operation getTaskWithHttpInfo
     *
     * Get a task
     *
     * @param  string $task_id The id of the task to get. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\TaskResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTaskWithHttpInfo($task_id)
    {
        $returnType = '\Swagger\Client\Model\TaskResponse';
        $request = $this->getTaskRequest($task_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\TaskResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTaskAsync
     *
     * Get a task
     *
     * @param  string $task_id The id of the task to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTaskAsync($task_id)
    {
        return $this->getTaskAsyncWithHttpInfo($task_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTaskAsyncWithHttpInfo
     *
     * Get a task
     *
     * @param  string $task_id The id of the task to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTaskAsyncWithHttpInfo($task_id)
    {
        $returnType = '\Swagger\Client\Model\TaskResponse';
        $request = $this->getTaskRequest($task_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTask'
     *
     * @param  string $task_id The id of the task to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTaskRequest($task_id)
    {
        // verify the required parameter 'task_id' is set
        if ($task_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_id when calling getTask'
            );
        }

        $resourcePath = '/runtime/tasks/{taskId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($task_id !== null) {
            $resourcePath = str_replace(
                '{' . 'taskId' . '}',
                ObjectSerializer::toPathValue($task_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTaskComment
     *
     * Get a comment on a task
     *
     * @param  string $task_id The id of the task to get the comment for. (required)
     * @param  string $comment_id The id of the comment. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\CommentResponse
     */
    public function getTaskComment($task_id, $comment_id)
    {
        list($response) = $this->getTaskCommentWithHttpInfo($task_id, $comment_id);
        return $response;
    }

    /**
     * Operation getTaskCommentWithHttpInfo
     *
     * Get a comment on a task
     *
     * @param  string $task_id The id of the task to get the comment for. (required)
     * @param  string $comment_id The id of the comment. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\CommentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTaskCommentWithHttpInfo($task_id, $comment_id)
    {
        $returnType = '\Swagger\Client\Model\CommentResponse';
        $request = $this->getTaskCommentRequest($task_id, $comment_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\CommentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTaskCommentAsync
     *
     * Get a comment on a task
     *
     * @param  string $task_id The id of the task to get the comment for. (required)
     * @param  string $comment_id The id of the comment. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTaskCommentAsync($task_id, $comment_id)
    {
        return $this->getTaskCommentAsyncWithHttpInfo($task_id, $comment_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTaskCommentAsyncWithHttpInfo
     *
     * Get a comment on a task
     *
     * @param  string $task_id The id of the task to get the comment for. (required)
     * @param  string $comment_id The id of the comment. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTaskCommentAsyncWithHttpInfo($task_id, $comment_id)
    {
        $returnType = '\Swagger\Client\Model\CommentResponse';
        $request = $this->getTaskCommentRequest($task_id, $comment_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTaskComment'
     *
     * @param  string $task_id The id of the task to get the comment for. (required)
     * @param  string $comment_id The id of the comment. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTaskCommentRequest($task_id, $comment_id)
    {
        // verify the required parameter 'task_id' is set
        if ($task_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_id when calling getTaskComment'
            );
        }
        // verify the required parameter 'comment_id' is set
        if ($comment_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $comment_id when calling getTaskComment'
            );
        }

        $resourcePath = '/runtime/tasks/{taskId}/comments/{commentId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($task_id !== null) {
            $resourcePath = str_replace(
                '{' . 'taskId' . '}',
                ObjectSerializer::toPathValue($task_id),
                $resourcePath
            );
        }
        // path params
        if ($comment_id !== null) {
            $resourcePath = str_replace(
                '{' . 'commentId' . '}',
                ObjectSerializer::toPathValue($comment_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTaskInstanceIdentityLinks
     *
     * Get a single identity link on a task
     *
     * @param  string $task_id The id of the task . (required)
     * @param  string $family Either groups or users, depending on what kind of identity is targeted. (required)
     * @param  string $identity_id The id of the identity. (required)
     * @param  string $type The type of identity link. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\RestIdentityLink
     */
    public function getTaskInstanceIdentityLinks($task_id, $family, $identity_id, $type)
    {
        list($response) = $this->getTaskInstanceIdentityLinksWithHttpInfo($task_id, $family, $identity_id, $type);
        return $response;
    }

    /**
     * Operation getTaskInstanceIdentityLinksWithHttpInfo
     *
     * Get a single identity link on a task
     *
     * @param  string $task_id The id of the task . (required)
     * @param  string $family Either groups or users, depending on what kind of identity is targeted. (required)
     * @param  string $identity_id The id of the identity. (required)
     * @param  string $type The type of identity link. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\RestIdentityLink, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTaskInstanceIdentityLinksWithHttpInfo($task_id, $family, $identity_id, $type)
    {
        $returnType = '\Swagger\Client\Model\RestIdentityLink';
        $request = $this->getTaskInstanceIdentityLinksRequest($task_id, $family, $identity_id, $type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\RestIdentityLink',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTaskInstanceIdentityLinksAsync
     *
     * Get a single identity link on a task
     *
     * @param  string $task_id The id of the task . (required)
     * @param  string $family Either groups or users, depending on what kind of identity is targeted. (required)
     * @param  string $identity_id The id of the identity. (required)
     * @param  string $type The type of identity link. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTaskInstanceIdentityLinksAsync($task_id, $family, $identity_id, $type)
    {
        return $this->getTaskInstanceIdentityLinksAsyncWithHttpInfo($task_id, $family, $identity_id, $type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTaskInstanceIdentityLinksAsyncWithHttpInfo
     *
     * Get a single identity link on a task
     *
     * @param  string $task_id The id of the task . (required)
     * @param  string $family Either groups or users, depending on what kind of identity is targeted. (required)
     * @param  string $identity_id The id of the identity. (required)
     * @param  string $type The type of identity link. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTaskInstanceIdentityLinksAsyncWithHttpInfo($task_id, $family, $identity_id, $type)
    {
        $returnType = '\Swagger\Client\Model\RestIdentityLink';
        $request = $this->getTaskInstanceIdentityLinksRequest($task_id, $family, $identity_id, $type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTaskInstanceIdentityLinks'
     *
     * @param  string $task_id The id of the task . (required)
     * @param  string $family Either groups or users, depending on what kind of identity is targeted. (required)
     * @param  string $identity_id The id of the identity. (required)
     * @param  string $type The type of identity link. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTaskInstanceIdentityLinksRequest($task_id, $family, $identity_id, $type)
    {
        // verify the required parameter 'task_id' is set
        if ($task_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_id when calling getTaskInstanceIdentityLinks'
            );
        }
        // verify the required parameter 'family' is set
        if ($family === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $family when calling getTaskInstanceIdentityLinks'
            );
        }
        // verify the required parameter 'identity_id' is set
        if ($identity_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $identity_id when calling getTaskInstanceIdentityLinks'
            );
        }
        // verify the required parameter 'type' is set
        if ($type === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling getTaskInstanceIdentityLinks'
            );
        }

        $resourcePath = '/runtime/tasks/{taskId}/identitylinks/{family}/{identityId}/{type}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($task_id !== null) {
            $resourcePath = str_replace(
                '{' . 'taskId' . '}',
                ObjectSerializer::toPathValue($task_id),
                $resourcePath
            );
        }
        // path params
        if ($family !== null) {
            $resourcePath = str_replace(
                '{' . 'family' . '}',
                ObjectSerializer::toPathValue($family),
                $resourcePath
            );
        }
        // path params
        if ($identity_id !== null) {
            $resourcePath = str_replace(
                '{' . 'identityId' . '}',
                ObjectSerializer::toPathValue($identity_id),
                $resourcePath
            );
        }
        // path params
        if ($type !== null) {
            $resourcePath = str_replace(
                '{' . 'type' . '}',
                ObjectSerializer::toPathValue($type),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTaskInstanceVariable
     *
     * Get a variable from a task
     *
     * @param  string $task_id The id of the task to get a variable for. (required)
     * @param  string $variable_name The name of the variable to get. (required)
     * @param  string $scope Scope of variable to be returned. When local, only task-local variable value is returned. When global, only variable value from the task�s parent execution-hierarchy are returned. When the parameter is omitted, a local variable will be returned if it exists, otherwise a global variable. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\RestVariable
     */
    public function getTaskInstanceVariable($task_id, $variable_name, $scope = null)
    {
        list($response) = $this->getTaskInstanceVariableWithHttpInfo($task_id, $variable_name, $scope);
        return $response;
    }

    /**
     * Operation getTaskInstanceVariableWithHttpInfo
     *
     * Get a variable from a task
     *
     * @param  string $task_id The id of the task to get a variable for. (required)
     * @param  string $variable_name The name of the variable to get. (required)
     * @param  string $scope Scope of variable to be returned. When local, only task-local variable value is returned. When global, only variable value from the task�s parent execution-hierarchy are returned. When the parameter is omitted, a local variable will be returned if it exists, otherwise a global variable. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\RestVariable, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTaskInstanceVariableWithHttpInfo($task_id, $variable_name, $scope = null)
    {
        $returnType = '\Swagger\Client\Model\RestVariable';
        $request = $this->getTaskInstanceVariableRequest($task_id, $variable_name, $scope);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\RestVariable',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTaskInstanceVariableAsync
     *
     * Get a variable from a task
     *
     * @param  string $task_id The id of the task to get a variable for. (required)
     * @param  string $variable_name The name of the variable to get. (required)
     * @param  string $scope Scope of variable to be returned. When local, only task-local variable value is returned. When global, only variable value from the task�s parent execution-hierarchy are returned. When the parameter is omitted, a local variable will be returned if it exists, otherwise a global variable. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTaskInstanceVariableAsync($task_id, $variable_name, $scope = null)
    {
        return $this->getTaskInstanceVariableAsyncWithHttpInfo($task_id, $variable_name, $scope)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTaskInstanceVariableAsyncWithHttpInfo
     *
     * Get a variable from a task
     *
     * @param  string $task_id The id of the task to get a variable for. (required)
     * @param  string $variable_name The name of the variable to get. (required)
     * @param  string $scope Scope of variable to be returned. When local, only task-local variable value is returned. When global, only variable value from the task�s parent execution-hierarchy are returned. When the parameter is omitted, a local variable will be returned if it exists, otherwise a global variable. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTaskInstanceVariableAsyncWithHttpInfo($task_id, $variable_name, $scope = null)
    {
        $returnType = '\Swagger\Client\Model\RestVariable';
        $request = $this->getTaskInstanceVariableRequest($task_id, $variable_name, $scope);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTaskInstanceVariable'
     *
     * @param  string $task_id The id of the task to get a variable for. (required)
     * @param  string $variable_name The name of the variable to get. (required)
     * @param  string $scope Scope of variable to be returned. When local, only task-local variable value is returned. When global, only variable value from the task�s parent execution-hierarchy are returned. When the parameter is omitted, a local variable will be returned if it exists, otherwise a global variable. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTaskInstanceVariableRequest($task_id, $variable_name, $scope = null)
    {
        // verify the required parameter 'task_id' is set
        if ($task_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_id when calling getTaskInstanceVariable'
            );
        }
        // verify the required parameter 'variable_name' is set
        if ($variable_name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $variable_name when calling getTaskInstanceVariable'
            );
        }

        $resourcePath = '/runtime/tasks/{taskId}/variables/{variableName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($scope !== null) {
            $queryParams['scope'] = ObjectSerializer::toQueryValue($scope);
        }

        // path params
        if ($task_id !== null) {
            $resourcePath = str_replace(
                '{' . 'taskId' . '}',
                ObjectSerializer::toPathValue($task_id),
                $resourcePath
            );
        }
        // path params
        if ($variable_name !== null) {
            $resourcePath = str_replace(
                '{' . 'variableName' . '}',
                ObjectSerializer::toPathValue($variable_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTasks
     *
     * List of tasks
     *
     * @param  string $name Only return models with the given version. (optional)
     * @param  string $name_like Only return tasks with a name like the given name. (optional)
     * @param  string $description Only return tasks with the given description. (optional)
     * @param  string $priority Only return tasks with the given priority. (optional)
     * @param  string $minimum_priority Only return tasks with a priority greater than the given value. (optional)
     * @param  string $maximum_priority Only return tasks with a priority lower than the given value. (optional)
     * @param  string $assignee Only return tasks assigned to the given user. (optional)
     * @param  string $assignee_like Only return tasks assigned with an assignee like the given value. (optional)
     * @param  string $owner Only return tasks owned by the given user. (optional)
     * @param  string $owner_like Only return tasks assigned with an owner like the given value. (optional)
     * @param  string $unassigned Only return tasks that are not assigned to anyone. If false is passed, the value is ignored. (optional)
     * @param  string $delegation_state Only return tasks that have the given delegation state. Possible values are pending and resolved. (optional)
     * @param  string $candidate_user Only return tasks that can be claimed by the given user. This includes both tasks where the user is an explicit candidate for and task that are claimable by a group that the user is a member of. (optional)
     * @param  string $candidate_group Only return tasks that can be claimed by a user in the given group. (optional)
     * @param  string $candidate_groups Only return tasks that can be claimed by a user in the given groups. Values split by comma. (optional)
     * @param  string $involved_user Only return tasks in which the given user is involved. (optional)
     * @param  string $task_definition_key Only return tasks with the given task definition id. (optional)
     * @param  string $task_definition_key_like Only return tasks with a given task definition id like the given value. (optional)
     * @param  string $process_instance_id Only return tasks which are part of the process instance with the given id. (optional)
     * @param  string $process_instance_business_key Only return tasks which are part of the process instance with the given business key. (optional)
     * @param  string $process_instance_business_key_like Only return tasks which are part of the process instance which has a business key like the given value. (optional)
     * @param  string $process_definition_id Only return tasks which are part of a process instance which has a process definition with the given id. (optional)
     * @param  string $process_definition_key Only return tasks which are part of a process instance which has a process definition with the given key. (optional)
     * @param  string $process_definition_key_like Only return tasks which are part of a process instance which has a process definition with a key like the given value. (optional)
     * @param  string $process_definition_name Only return tasks which are part of a process instance which has a process definition with the given name. (optional)
     * @param  string $process_definition_name_like Only return tasks which are part of a process instance which has a process definition with a name like the given value. (optional)
     * @param  string $execution_id Only return tasks which are part of the execution with the given id. (optional)
     * @param  string $created_on Only return tasks which are created on the given date. (optional)
     * @param  string $created_before Only return tasks which are created before the given date. (optional)
     * @param  string $created_after Only return tasks which are created after the given date. (optional)
     * @param  string $due_on Only return tasks which are due on the given date. (optional)
     * @param  string $due_before Only return tasks which are due before the given date. (optional)
     * @param  string $due_after Only return tasks which are due after the given date. (optional)
     * @param  bool $without_due_date Only return tasks which don�t have a due date. The property is ignored if the value is false. (optional)
     * @param  bool $exclude_sub_tasks Only return tasks that are not a subtask of another task. (optional)
     * @param  bool $active If true, only return tasks that are not suspended (either part of a process that is not suspended or not part of a process at all). If false, only tasks that are part of suspended process instances are returned. (optional)
     * @param  bool $include_task_local_variables Indication to include task local variables in the result. (optional)
     * @param  bool $include_process_variables Indication to include process variables in the result. (optional)
     * @param  string $tenant_id Only return tasks with the given tenantId. (optional)
     * @param  string $tenant_id_like Only return tasks with a tenantId like the given value. (optional)
     * @param  bool $without_tenant_id If true, only returns tasks without a tenantId set. If false, the withoutTenantId parameter is ignored. (optional)
     * @param  string $candidate_or_assigned Select tasks that has been claimed or assigned to user or waiting to claim by user (candidate user or groups). (optional)
     * @param  string $category Select tasks with the given category. Note that this is the task category, not the category of the process definition (namespace within the BPMN Xml). (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\DataResponse
     */
    public function getTasks($name = null, $name_like = null, $description = null, $priority = null, $minimum_priority = null, $maximum_priority = null, $assignee = null, $assignee_like = null, $owner = null, $owner_like = null, $unassigned = null, $delegation_state = null, $candidate_user = null, $candidate_group = null, $candidate_groups = null, $involved_user = null, $task_definition_key = null, $task_definition_key_like = null, $process_instance_id = null, $process_instance_business_key = null, $process_instance_business_key_like = null, $process_definition_id = null, $process_definition_key = null, $process_definition_key_like = null, $process_definition_name = null, $process_definition_name_like = null, $execution_id = null, $created_on = null, $created_before = null, $created_after = null, $due_on = null, $due_before = null, $due_after = null, $without_due_date = null, $exclude_sub_tasks = null, $active = null, $include_task_local_variables = null, $include_process_variables = null, $tenant_id = null, $tenant_id_like = null, $without_tenant_id = null, $candidate_or_assigned = null, $category = null)
    {
        list($response) = $this->getTasksWithHttpInfo($name, $name_like, $description, $priority, $minimum_priority, $maximum_priority, $assignee, $assignee_like, $owner, $owner_like, $unassigned, $delegation_state, $candidate_user, $candidate_group, $candidate_groups, $involved_user, $task_definition_key, $task_definition_key_like, $process_instance_id, $process_instance_business_key, $process_instance_business_key_like, $process_definition_id, $process_definition_key, $process_definition_key_like, $process_definition_name, $process_definition_name_like, $execution_id, $created_on, $created_before, $created_after, $due_on, $due_before, $due_after, $without_due_date, $exclude_sub_tasks, $active, $include_task_local_variables, $include_process_variables, $tenant_id, $tenant_id_like, $without_tenant_id, $candidate_or_assigned, $category);
        return $response;
    }

    /**
     * Operation getTasksWithHttpInfo
     *
     * List of tasks
     *
     * @param  string $name Only return models with the given version. (optional)
     * @param  string $name_like Only return tasks with a name like the given name. (optional)
     * @param  string $description Only return tasks with the given description. (optional)
     * @param  string $priority Only return tasks with the given priority. (optional)
     * @param  string $minimum_priority Only return tasks with a priority greater than the given value. (optional)
     * @param  string $maximum_priority Only return tasks with a priority lower than the given value. (optional)
     * @param  string $assignee Only return tasks assigned to the given user. (optional)
     * @param  string $assignee_like Only return tasks assigned with an assignee like the given value. (optional)
     * @param  string $owner Only return tasks owned by the given user. (optional)
     * @param  string $owner_like Only return tasks assigned with an owner like the given value. (optional)
     * @param  string $unassigned Only return tasks that are not assigned to anyone. If false is passed, the value is ignored. (optional)
     * @param  string $delegation_state Only return tasks that have the given delegation state. Possible values are pending and resolved. (optional)
     * @param  string $candidate_user Only return tasks that can be claimed by the given user. This includes both tasks where the user is an explicit candidate for and task that are claimable by a group that the user is a member of. (optional)
     * @param  string $candidate_group Only return tasks that can be claimed by a user in the given group. (optional)
     * @param  string $candidate_groups Only return tasks that can be claimed by a user in the given groups. Values split by comma. (optional)
     * @param  string $involved_user Only return tasks in which the given user is involved. (optional)
     * @param  string $task_definition_key Only return tasks with the given task definition id. (optional)
     * @param  string $task_definition_key_like Only return tasks with a given task definition id like the given value. (optional)
     * @param  string $process_instance_id Only return tasks which are part of the process instance with the given id. (optional)
     * @param  string $process_instance_business_key Only return tasks which are part of the process instance with the given business key. (optional)
     * @param  string $process_instance_business_key_like Only return tasks which are part of the process instance which has a business key like the given value. (optional)
     * @param  string $process_definition_id Only return tasks which are part of a process instance which has a process definition with the given id. (optional)
     * @param  string $process_definition_key Only return tasks which are part of a process instance which has a process definition with the given key. (optional)
     * @param  string $process_definition_key_like Only return tasks which are part of a process instance which has a process definition with a key like the given value. (optional)
     * @param  string $process_definition_name Only return tasks which are part of a process instance which has a process definition with the given name. (optional)
     * @param  string $process_definition_name_like Only return tasks which are part of a process instance which has a process definition with a name like the given value. (optional)
     * @param  string $execution_id Only return tasks which are part of the execution with the given id. (optional)
     * @param  string $created_on Only return tasks which are created on the given date. (optional)
     * @param  string $created_before Only return tasks which are created before the given date. (optional)
     * @param  string $created_after Only return tasks which are created after the given date. (optional)
     * @param  string $due_on Only return tasks which are due on the given date. (optional)
     * @param  string $due_before Only return tasks which are due before the given date. (optional)
     * @param  string $due_after Only return tasks which are due after the given date. (optional)
     * @param  bool $without_due_date Only return tasks which don�t have a due date. The property is ignored if the value is false. (optional)
     * @param  bool $exclude_sub_tasks Only return tasks that are not a subtask of another task. (optional)
     * @param  bool $active If true, only return tasks that are not suspended (either part of a process that is not suspended or not part of a process at all). If false, only tasks that are part of suspended process instances are returned. (optional)
     * @param  bool $include_task_local_variables Indication to include task local variables in the result. (optional)
     * @param  bool $include_process_variables Indication to include process variables in the result. (optional)
     * @param  string $tenant_id Only return tasks with the given tenantId. (optional)
     * @param  string $tenant_id_like Only return tasks with a tenantId like the given value. (optional)
     * @param  bool $without_tenant_id If true, only returns tasks without a tenantId set. If false, the withoutTenantId parameter is ignored. (optional)
     * @param  string $candidate_or_assigned Select tasks that has been claimed or assigned to user or waiting to claim by user (candidate user or groups). (optional)
     * @param  string $category Select tasks with the given category. Note that this is the task category, not the category of the process definition (namespace within the BPMN Xml). (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\DataResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTasksWithHttpInfo($name = null, $name_like = null, $description = null, $priority = null, $minimum_priority = null, $maximum_priority = null, $assignee = null, $assignee_like = null, $owner = null, $owner_like = null, $unassigned = null, $delegation_state = null, $candidate_user = null, $candidate_group = null, $candidate_groups = null, $involved_user = null, $task_definition_key = null, $task_definition_key_like = null, $process_instance_id = null, $process_instance_business_key = null, $process_instance_business_key_like = null, $process_definition_id = null, $process_definition_key = null, $process_definition_key_like = null, $process_definition_name = null, $process_definition_name_like = null, $execution_id = null, $created_on = null, $created_before = null, $created_after = null, $due_on = null, $due_before = null, $due_after = null, $without_due_date = null, $exclude_sub_tasks = null, $active = null, $include_task_local_variables = null, $include_process_variables = null, $tenant_id = null, $tenant_id_like = null, $without_tenant_id = null, $candidate_or_assigned = null, $category = null)
    {
        $returnType = '\Swagger\Client\Model\DataResponse';
        $request = $this->getTasksRequest($name, $name_like, $description, $priority, $minimum_priority, $maximum_priority, $assignee, $assignee_like, $owner, $owner_like, $unassigned, $delegation_state, $candidate_user, $candidate_group, $candidate_groups, $involved_user, $task_definition_key, $task_definition_key_like, $process_instance_id, $process_instance_business_key, $process_instance_business_key_like, $process_definition_id, $process_definition_key, $process_definition_key_like, $process_definition_name, $process_definition_name_like, $execution_id, $created_on, $created_before, $created_after, $due_on, $due_before, $due_after, $without_due_date, $exclude_sub_tasks, $active, $include_task_local_variables, $include_process_variables, $tenant_id, $tenant_id_like, $without_tenant_id, $candidate_or_assigned, $category);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\DataResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTasksAsync
     *
     * List of tasks
     *
     * @param  string $name Only return models with the given version. (optional)
     * @param  string $name_like Only return tasks with a name like the given name. (optional)
     * @param  string $description Only return tasks with the given description. (optional)
     * @param  string $priority Only return tasks with the given priority. (optional)
     * @param  string $minimum_priority Only return tasks with a priority greater than the given value. (optional)
     * @param  string $maximum_priority Only return tasks with a priority lower than the given value. (optional)
     * @param  string $assignee Only return tasks assigned to the given user. (optional)
     * @param  string $assignee_like Only return tasks assigned with an assignee like the given value. (optional)
     * @param  string $owner Only return tasks owned by the given user. (optional)
     * @param  string $owner_like Only return tasks assigned with an owner like the given value. (optional)
     * @param  string $unassigned Only return tasks that are not assigned to anyone. If false is passed, the value is ignored. (optional)
     * @param  string $delegation_state Only return tasks that have the given delegation state. Possible values are pending and resolved. (optional)
     * @param  string $candidate_user Only return tasks that can be claimed by the given user. This includes both tasks where the user is an explicit candidate for and task that are claimable by a group that the user is a member of. (optional)
     * @param  string $candidate_group Only return tasks that can be claimed by a user in the given group. (optional)
     * @param  string $candidate_groups Only return tasks that can be claimed by a user in the given groups. Values split by comma. (optional)
     * @param  string $involved_user Only return tasks in which the given user is involved. (optional)
     * @param  string $task_definition_key Only return tasks with the given task definition id. (optional)
     * @param  string $task_definition_key_like Only return tasks with a given task definition id like the given value. (optional)
     * @param  string $process_instance_id Only return tasks which are part of the process instance with the given id. (optional)
     * @param  string $process_instance_business_key Only return tasks which are part of the process instance with the given business key. (optional)
     * @param  string $process_instance_business_key_like Only return tasks which are part of the process instance which has a business key like the given value. (optional)
     * @param  string $process_definition_id Only return tasks which are part of a process instance which has a process definition with the given id. (optional)
     * @param  string $process_definition_key Only return tasks which are part of a process instance which has a process definition with the given key. (optional)
     * @param  string $process_definition_key_like Only return tasks which are part of a process instance which has a process definition with a key like the given value. (optional)
     * @param  string $process_definition_name Only return tasks which are part of a process instance which has a process definition with the given name. (optional)
     * @param  string $process_definition_name_like Only return tasks which are part of a process instance which has a process definition with a name like the given value. (optional)
     * @param  string $execution_id Only return tasks which are part of the execution with the given id. (optional)
     * @param  string $created_on Only return tasks which are created on the given date. (optional)
     * @param  string $created_before Only return tasks which are created before the given date. (optional)
     * @param  string $created_after Only return tasks which are created after the given date. (optional)
     * @param  string $due_on Only return tasks which are due on the given date. (optional)
     * @param  string $due_before Only return tasks which are due before the given date. (optional)
     * @param  string $due_after Only return tasks which are due after the given date. (optional)
     * @param  bool $without_due_date Only return tasks which don�t have a due date. The property is ignored if the value is false. (optional)
     * @param  bool $exclude_sub_tasks Only return tasks that are not a subtask of another task. (optional)
     * @param  bool $active If true, only return tasks that are not suspended (either part of a process that is not suspended or not part of a process at all). If false, only tasks that are part of suspended process instances are returned. (optional)
     * @param  bool $include_task_local_variables Indication to include task local variables in the result. (optional)
     * @param  bool $include_process_variables Indication to include process variables in the result. (optional)
     * @param  string $tenant_id Only return tasks with the given tenantId. (optional)
     * @param  string $tenant_id_like Only return tasks with a tenantId like the given value. (optional)
     * @param  bool $without_tenant_id If true, only returns tasks without a tenantId set. If false, the withoutTenantId parameter is ignored. (optional)
     * @param  string $candidate_or_assigned Select tasks that has been claimed or assigned to user or waiting to claim by user (candidate user or groups). (optional)
     * @param  string $category Select tasks with the given category. Note that this is the task category, not the category of the process definition (namespace within the BPMN Xml). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTasksAsync($name = null, $name_like = null, $description = null, $priority = null, $minimum_priority = null, $maximum_priority = null, $assignee = null, $assignee_like = null, $owner = null, $owner_like = null, $unassigned = null, $delegation_state = null, $candidate_user = null, $candidate_group = null, $candidate_groups = null, $involved_user = null, $task_definition_key = null, $task_definition_key_like = null, $process_instance_id = null, $process_instance_business_key = null, $process_instance_business_key_like = null, $process_definition_id = null, $process_definition_key = null, $process_definition_key_like = null, $process_definition_name = null, $process_definition_name_like = null, $execution_id = null, $created_on = null, $created_before = null, $created_after = null, $due_on = null, $due_before = null, $due_after = null, $without_due_date = null, $exclude_sub_tasks = null, $active = null, $include_task_local_variables = null, $include_process_variables = null, $tenant_id = null, $tenant_id_like = null, $without_tenant_id = null, $candidate_or_assigned = null, $category = null)
    {
        return $this->getTasksAsyncWithHttpInfo($name, $name_like, $description, $priority, $minimum_priority, $maximum_priority, $assignee, $assignee_like, $owner, $owner_like, $unassigned, $delegation_state, $candidate_user, $candidate_group, $candidate_groups, $involved_user, $task_definition_key, $task_definition_key_like, $process_instance_id, $process_instance_business_key, $process_instance_business_key_like, $process_definition_id, $process_definition_key, $process_definition_key_like, $process_definition_name, $process_definition_name_like, $execution_id, $created_on, $created_before, $created_after, $due_on, $due_before, $due_after, $without_due_date, $exclude_sub_tasks, $active, $include_task_local_variables, $include_process_variables, $tenant_id, $tenant_id_like, $without_tenant_id, $candidate_or_assigned, $category)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTasksAsyncWithHttpInfo
     *
     * List of tasks
     *
     * @param  string $name Only return models with the given version. (optional)
     * @param  string $name_like Only return tasks with a name like the given name. (optional)
     * @param  string $description Only return tasks with the given description. (optional)
     * @param  string $priority Only return tasks with the given priority. (optional)
     * @param  string $minimum_priority Only return tasks with a priority greater than the given value. (optional)
     * @param  string $maximum_priority Only return tasks with a priority lower than the given value. (optional)
     * @param  string $assignee Only return tasks assigned to the given user. (optional)
     * @param  string $assignee_like Only return tasks assigned with an assignee like the given value. (optional)
     * @param  string $owner Only return tasks owned by the given user. (optional)
     * @param  string $owner_like Only return tasks assigned with an owner like the given value. (optional)
     * @param  string $unassigned Only return tasks that are not assigned to anyone. If false is passed, the value is ignored. (optional)
     * @param  string $delegation_state Only return tasks that have the given delegation state. Possible values are pending and resolved. (optional)
     * @param  string $candidate_user Only return tasks that can be claimed by the given user. This includes both tasks where the user is an explicit candidate for and task that are claimable by a group that the user is a member of. (optional)
     * @param  string $candidate_group Only return tasks that can be claimed by a user in the given group. (optional)
     * @param  string $candidate_groups Only return tasks that can be claimed by a user in the given groups. Values split by comma. (optional)
     * @param  string $involved_user Only return tasks in which the given user is involved. (optional)
     * @param  string $task_definition_key Only return tasks with the given task definition id. (optional)
     * @param  string $task_definition_key_like Only return tasks with a given task definition id like the given value. (optional)
     * @param  string $process_instance_id Only return tasks which are part of the process instance with the given id. (optional)
     * @param  string $process_instance_business_key Only return tasks which are part of the process instance with the given business key. (optional)
     * @param  string $process_instance_business_key_like Only return tasks which are part of the process instance which has a business key like the given value. (optional)
     * @param  string $process_definition_id Only return tasks which are part of a process instance which has a process definition with the given id. (optional)
     * @param  string $process_definition_key Only return tasks which are part of a process instance which has a process definition with the given key. (optional)
     * @param  string $process_definition_key_like Only return tasks which are part of a process instance which has a process definition with a key like the given value. (optional)
     * @param  string $process_definition_name Only return tasks which are part of a process instance which has a process definition with the given name. (optional)
     * @param  string $process_definition_name_like Only return tasks which are part of a process instance which has a process definition with a name like the given value. (optional)
     * @param  string $execution_id Only return tasks which are part of the execution with the given id. (optional)
     * @param  string $created_on Only return tasks which are created on the given date. (optional)
     * @param  string $created_before Only return tasks which are created before the given date. (optional)
     * @param  string $created_after Only return tasks which are created after the given date. (optional)
     * @param  string $due_on Only return tasks which are due on the given date. (optional)
     * @param  string $due_before Only return tasks which are due before the given date. (optional)
     * @param  string $due_after Only return tasks which are due after the given date. (optional)
     * @param  bool $without_due_date Only return tasks which don�t have a due date. The property is ignored if the value is false. (optional)
     * @param  bool $exclude_sub_tasks Only return tasks that are not a subtask of another task. (optional)
     * @param  bool $active If true, only return tasks that are not suspended (either part of a process that is not suspended or not part of a process at all). If false, only tasks that are part of suspended process instances are returned. (optional)
     * @param  bool $include_task_local_variables Indication to include task local variables in the result. (optional)
     * @param  bool $include_process_variables Indication to include process variables in the result. (optional)
     * @param  string $tenant_id Only return tasks with the given tenantId. (optional)
     * @param  string $tenant_id_like Only return tasks with a tenantId like the given value. (optional)
     * @param  bool $without_tenant_id If true, only returns tasks without a tenantId set. If false, the withoutTenantId parameter is ignored. (optional)
     * @param  string $candidate_or_assigned Select tasks that has been claimed or assigned to user or waiting to claim by user (candidate user or groups). (optional)
     * @param  string $category Select tasks with the given category. Note that this is the task category, not the category of the process definition (namespace within the BPMN Xml). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTasksAsyncWithHttpInfo($name = null, $name_like = null, $description = null, $priority = null, $minimum_priority = null, $maximum_priority = null, $assignee = null, $assignee_like = null, $owner = null, $owner_like = null, $unassigned = null, $delegation_state = null, $candidate_user = null, $candidate_group = null, $candidate_groups = null, $involved_user = null, $task_definition_key = null, $task_definition_key_like = null, $process_instance_id = null, $process_instance_business_key = null, $process_instance_business_key_like = null, $process_definition_id = null, $process_definition_key = null, $process_definition_key_like = null, $process_definition_name = null, $process_definition_name_like = null, $execution_id = null, $created_on = null, $created_before = null, $created_after = null, $due_on = null, $due_before = null, $due_after = null, $without_due_date = null, $exclude_sub_tasks = null, $active = null, $include_task_local_variables = null, $include_process_variables = null, $tenant_id = null, $tenant_id_like = null, $without_tenant_id = null, $candidate_or_assigned = null, $category = null)
    {
        $returnType = '\Swagger\Client\Model\DataResponse';
        $request = $this->getTasksRequest($name, $name_like, $description, $priority, $minimum_priority, $maximum_priority, $assignee, $assignee_like, $owner, $owner_like, $unassigned, $delegation_state, $candidate_user, $candidate_group, $candidate_groups, $involved_user, $task_definition_key, $task_definition_key_like, $process_instance_id, $process_instance_business_key, $process_instance_business_key_like, $process_definition_id, $process_definition_key, $process_definition_key_like, $process_definition_name, $process_definition_name_like, $execution_id, $created_on, $created_before, $created_after, $due_on, $due_before, $due_after, $without_due_date, $exclude_sub_tasks, $active, $include_task_local_variables, $include_process_variables, $tenant_id, $tenant_id_like, $without_tenant_id, $candidate_or_assigned, $category);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTasks'
     *
     * @param  string $name Only return models with the given version. (optional)
     * @param  string $name_like Only return tasks with a name like the given name. (optional)
     * @param  string $description Only return tasks with the given description. (optional)
     * @param  string $priority Only return tasks with the given priority. (optional)
     * @param  string $minimum_priority Only return tasks with a priority greater than the given value. (optional)
     * @param  string $maximum_priority Only return tasks with a priority lower than the given value. (optional)
     * @param  string $assignee Only return tasks assigned to the given user. (optional)
     * @param  string $assignee_like Only return tasks assigned with an assignee like the given value. (optional)
     * @param  string $owner Only return tasks owned by the given user. (optional)
     * @param  string $owner_like Only return tasks assigned with an owner like the given value. (optional)
     * @param  string $unassigned Only return tasks that are not assigned to anyone. If false is passed, the value is ignored. (optional)
     * @param  string $delegation_state Only return tasks that have the given delegation state. Possible values are pending and resolved. (optional)
     * @param  string $candidate_user Only return tasks that can be claimed by the given user. This includes both tasks where the user is an explicit candidate for and task that are claimable by a group that the user is a member of. (optional)
     * @param  string $candidate_group Only return tasks that can be claimed by a user in the given group. (optional)
     * @param  string $candidate_groups Only return tasks that can be claimed by a user in the given groups. Values split by comma. (optional)
     * @param  string $involved_user Only return tasks in which the given user is involved. (optional)
     * @param  string $task_definition_key Only return tasks with the given task definition id. (optional)
     * @param  string $task_definition_key_like Only return tasks with a given task definition id like the given value. (optional)
     * @param  string $process_instance_id Only return tasks which are part of the process instance with the given id. (optional)
     * @param  string $process_instance_business_key Only return tasks which are part of the process instance with the given business key. (optional)
     * @param  string $process_instance_business_key_like Only return tasks which are part of the process instance which has a business key like the given value. (optional)
     * @param  string $process_definition_id Only return tasks which are part of a process instance which has a process definition with the given id. (optional)
     * @param  string $process_definition_key Only return tasks which are part of a process instance which has a process definition with the given key. (optional)
     * @param  string $process_definition_key_like Only return tasks which are part of a process instance which has a process definition with a key like the given value. (optional)
     * @param  string $process_definition_name Only return tasks which are part of a process instance which has a process definition with the given name. (optional)
     * @param  string $process_definition_name_like Only return tasks which are part of a process instance which has a process definition with a name like the given value. (optional)
     * @param  string $execution_id Only return tasks which are part of the execution with the given id. (optional)
     * @param  string $created_on Only return tasks which are created on the given date. (optional)
     * @param  string $created_before Only return tasks which are created before the given date. (optional)
     * @param  string $created_after Only return tasks which are created after the given date. (optional)
     * @param  string $due_on Only return tasks which are due on the given date. (optional)
     * @param  string $due_before Only return tasks which are due before the given date. (optional)
     * @param  string $due_after Only return tasks which are due after the given date. (optional)
     * @param  bool $without_due_date Only return tasks which don�t have a due date. The property is ignored if the value is false. (optional)
     * @param  bool $exclude_sub_tasks Only return tasks that are not a subtask of another task. (optional)
     * @param  bool $active If true, only return tasks that are not suspended (either part of a process that is not suspended or not part of a process at all). If false, only tasks that are part of suspended process instances are returned. (optional)
     * @param  bool $include_task_local_variables Indication to include task local variables in the result. (optional)
     * @param  bool $include_process_variables Indication to include process variables in the result. (optional)
     * @param  string $tenant_id Only return tasks with the given tenantId. (optional)
     * @param  string $tenant_id_like Only return tasks with a tenantId like the given value. (optional)
     * @param  bool $without_tenant_id If true, only returns tasks without a tenantId set. If false, the withoutTenantId parameter is ignored. (optional)
     * @param  string $candidate_or_assigned Select tasks that has been claimed or assigned to user or waiting to claim by user (candidate user or groups). (optional)
     * @param  string $category Select tasks with the given category. Note that this is the task category, not the category of the process definition (namespace within the BPMN Xml). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTasksRequest($name = null, $name_like = null, $description = null, $priority = null, $minimum_priority = null, $maximum_priority = null, $assignee = null, $assignee_like = null, $owner = null, $owner_like = null, $unassigned = null, $delegation_state = null, $candidate_user = null, $candidate_group = null, $candidate_groups = null, $involved_user = null, $task_definition_key = null, $task_definition_key_like = null, $process_instance_id = null, $process_instance_business_key = null, $process_instance_business_key_like = null, $process_definition_id = null, $process_definition_key = null, $process_definition_key_like = null, $process_definition_name = null, $process_definition_name_like = null, $execution_id = null, $created_on = null, $created_before = null, $created_after = null, $due_on = null, $due_before = null, $due_after = null, $without_due_date = null, $exclude_sub_tasks = null, $active = null, $include_task_local_variables = null, $include_process_variables = null, $tenant_id = null, $tenant_id_like = null, $without_tenant_id = null, $candidate_or_assigned = null, $category = null)
    {

        $resourcePath = '/runtime/tasks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($name_like !== null) {
            $queryParams['nameLike'] = ObjectSerializer::toQueryValue($name_like);
        }
        // query params
        if ($description !== null) {
            $queryParams['description'] = ObjectSerializer::toQueryValue($description);
        }
        // query params
        if ($priority !== null) {
            $queryParams['priority'] = ObjectSerializer::toQueryValue($priority);
        }
        // query params
        if ($minimum_priority !== null) {
            $queryParams['minimumPriority'] = ObjectSerializer::toQueryValue($minimum_priority);
        }
        // query params
        if ($maximum_priority !== null) {
            $queryParams['maximumPriority'] = ObjectSerializer::toQueryValue($maximum_priority);
        }
        // query params
        if ($assignee !== null) {
            $queryParams['assignee'] = ObjectSerializer::toQueryValue($assignee);
        }
        // query params
        if ($assignee_like !== null) {
            $queryParams['assigneeLike'] = ObjectSerializer::toQueryValue($assignee_like);
        }
        // query params
        if ($owner !== null) {
            $queryParams['owner'] = ObjectSerializer::toQueryValue($owner);
        }
        // query params
        if ($owner_like !== null) {
            $queryParams['ownerLike'] = ObjectSerializer::toQueryValue($owner_like);
        }
        // query params
        if ($unassigned !== null) {
            $queryParams['unassigned'] = ObjectSerializer::toQueryValue($unassigned);
        }
        // query params
        if ($delegation_state !== null) {
            $queryParams['delegationState'] = ObjectSerializer::toQueryValue($delegation_state);
        }
        // query params
        if ($candidate_user !== null) {
            $queryParams['candidateUser'] = ObjectSerializer::toQueryValue($candidate_user);
        }
        // query params
        if ($candidate_group !== null) {
            $queryParams['candidateGroup'] = ObjectSerializer::toQueryValue($candidate_group);
        }
        // query params
        if ($candidate_groups !== null) {
            $queryParams['candidateGroups'] = ObjectSerializer::toQueryValue($candidate_groups);
        }
        // query params
        if ($involved_user !== null) {
            $queryParams['involvedUser'] = ObjectSerializer::toQueryValue($involved_user);
        }
        // query params
        if ($task_definition_key !== null) {
            $queryParams['taskDefinitionKey'] = ObjectSerializer::toQueryValue($task_definition_key);
        }
        // query params
        if ($task_definition_key_like !== null) {
            $queryParams['taskDefinitionKeyLike'] = ObjectSerializer::toQueryValue($task_definition_key_like);
        }
        // query params
        if ($process_instance_id !== null) {
            $queryParams['processInstanceId'] = ObjectSerializer::toQueryValue($process_instance_id);
        }
        // query params
        if ($process_instance_business_key !== null) {
            $queryParams['processInstanceBusinessKey'] = ObjectSerializer::toQueryValue($process_instance_business_key);
        }
        // query params
        if ($process_instance_business_key_like !== null) {
            $queryParams['processInstanceBusinessKeyLike'] = ObjectSerializer::toQueryValue($process_instance_business_key_like);
        }
        // query params
        if ($process_definition_id !== null) {
            $queryParams['processDefinitionId'] = ObjectSerializer::toQueryValue($process_definition_id);
        }
        // query params
        if ($process_definition_key !== null) {
            $queryParams['processDefinitionKey'] = ObjectSerializer::toQueryValue($process_definition_key);
        }
        // query params
        if ($process_definition_key_like !== null) {
            $queryParams['processDefinitionKeyLike'] = ObjectSerializer::toQueryValue($process_definition_key_like);
        }
        // query params
        if ($process_definition_name !== null) {
            $queryParams['processDefinitionName'] = ObjectSerializer::toQueryValue($process_definition_name);
        }
        // query params
        if ($process_definition_name_like !== null) {
            $queryParams['processDefinitionNameLike'] = ObjectSerializer::toQueryValue($process_definition_name_like);
        }
        // query params
        if ($execution_id !== null) {
            $queryParams['executionId'] = ObjectSerializer::toQueryValue($execution_id);
        }
        // query params
        if ($created_on !== null) {
            $queryParams['createdOn'] = ObjectSerializer::toQueryValue($created_on);
        }
        // query params
        if ($created_before !== null) {
            $queryParams['createdBefore'] = ObjectSerializer::toQueryValue($created_before);
        }
        // query params
        if ($created_after !== null) {
            $queryParams['createdAfter'] = ObjectSerializer::toQueryValue($created_after);
        }
        // query params
        if ($due_on !== null) {
            $queryParams['dueOn'] = ObjectSerializer::toQueryValue($due_on);
        }
        // query params
        if ($due_before !== null) {
            $queryParams['dueBefore'] = ObjectSerializer::toQueryValue($due_before);
        }
        // query params
        if ($due_after !== null) {
            $queryParams['dueAfter'] = ObjectSerializer::toQueryValue($due_after);
        }
        // query params
        if ($without_due_date !== null) {
            $queryParams['withoutDueDate'] = ObjectSerializer::toQueryValue($without_due_date);
        }
        // query params
        if ($exclude_sub_tasks !== null) {
            $queryParams['excludeSubTasks'] = ObjectSerializer::toQueryValue($exclude_sub_tasks);
        }
        // query params
        if ($active !== null) {
            $queryParams['active'] = ObjectSerializer::toQueryValue($active);
        }
        // query params
        if ($include_task_local_variables !== null) {
            $queryParams['includeTaskLocalVariables'] = ObjectSerializer::toQueryValue($include_task_local_variables);
        }
        // query params
        if ($include_process_variables !== null) {
            $queryParams['includeProcessVariables'] = ObjectSerializer::toQueryValue($include_process_variables);
        }
        // query params
        if ($tenant_id !== null) {
            $queryParams['tenantId'] = ObjectSerializer::toQueryValue($tenant_id);
        }
        // query params
        if ($tenant_id_like !== null) {
            $queryParams['tenantIdLike'] = ObjectSerializer::toQueryValue($tenant_id_like);
        }
        // query params
        if ($without_tenant_id !== null) {
            $queryParams['withoutTenantId'] = ObjectSerializer::toQueryValue($without_tenant_id);
        }
        // query params
        if ($candidate_or_assigned !== null) {
            $queryParams['candidateOrAssigned'] = ObjectSerializer::toQueryValue($candidate_or_assigned);
        }
        // query params
        if ($category !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($category);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listTaskComments
     *
     * Get all comments on a task
     *
     * @param  string $task_id The id of the task to get the comments for. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\CommentResponse[]
     */
    public function listTaskComments($task_id)
    {
        list($response) = $this->listTaskCommentsWithHttpInfo($task_id);
        return $response;
    }

    /**
     * Operation listTaskCommentsWithHttpInfo
     *
     * Get all comments on a task
     *
     * @param  string $task_id The id of the task to get the comments for. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\CommentResponse[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listTaskCommentsWithHttpInfo($task_id)
    {
        $returnType = '\Swagger\Client\Model\CommentResponse[]';
        $request = $this->listTaskCommentsRequest($task_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\CommentResponse[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listTaskCommentsAsync
     *
     * Get all comments on a task
     *
     * @param  string $task_id The id of the task to get the comments for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listTaskCommentsAsync($task_id)
    {
        return $this->listTaskCommentsAsyncWithHttpInfo($task_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listTaskCommentsAsyncWithHttpInfo
     *
     * Get all comments on a task
     *
     * @param  string $task_id The id of the task to get the comments for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listTaskCommentsAsyncWithHttpInfo($task_id)
    {
        $returnType = '\Swagger\Client\Model\CommentResponse[]';
        $request = $this->listTaskCommentsRequest($task_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listTaskComments'
     *
     * @param  string $task_id The id of the task to get the comments for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listTaskCommentsRequest($task_id)
    {
        // verify the required parameter 'task_id' is set
        if ($task_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_id when calling listTaskComments'
            );
        }

        $resourcePath = '/runtime/tasks/{taskId}/comments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($task_id !== null) {
            $resourcePath = str_replace(
                '{' . 'taskId' . '}',
                ObjectSerializer::toPathValue($task_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listTaskVariables
     *
     * Get all variables for a task
     *
     * @param  string $task_id The id of the task to get variables for. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\RestVariable[]
     */
    public function listTaskVariables($task_id)
    {
        list($response) = $this->listTaskVariablesWithHttpInfo($task_id);
        return $response;
    }

    /**
     * Operation listTaskVariablesWithHttpInfo
     *
     * Get all variables for a task
     *
     * @param  string $task_id The id of the task to get variables for. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\RestVariable[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listTaskVariablesWithHttpInfo($task_id)
    {
        $returnType = '\Swagger\Client\Model\RestVariable[]';
        $request = $this->listTaskVariablesRequest($task_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\RestVariable[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listTaskVariablesAsync
     *
     * Get all variables for a task
     *
     * @param  string $task_id The id of the task to get variables for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listTaskVariablesAsync($task_id)
    {
        return $this->listTaskVariablesAsyncWithHttpInfo($task_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listTaskVariablesAsyncWithHttpInfo
     *
     * Get all variables for a task
     *
     * @param  string $task_id The id of the task to get variables for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listTaskVariablesAsyncWithHttpInfo($task_id)
    {
        $returnType = '\Swagger\Client\Model\RestVariable[]';
        $request = $this->listTaskVariablesRequest($task_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listTaskVariables'
     *
     * @param  string $task_id The id of the task to get variables for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listTaskVariablesRequest($task_id)
    {
        // verify the required parameter 'task_id' is set
        if ($task_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_id when calling listTaskVariables'
            );
        }

        $resourcePath = '/runtime/tasks/{taskId}/variables';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($task_id !== null) {
            $resourcePath = str_replace(
                '{' . 'taskId' . '}',
                ObjectSerializer::toPathValue($task_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listTasksInstanceIdentityLinks
     *
     * Get all identity links for a task
     *
     * @param  string $task_id The id of the task to get the identity links for. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\RestIdentityLink[]
     */
    public function listTasksInstanceIdentityLinks($task_id)
    {
        list($response) = $this->listTasksInstanceIdentityLinksWithHttpInfo($task_id);
        return $response;
    }

    /**
     * Operation listTasksInstanceIdentityLinksWithHttpInfo
     *
     * Get all identity links for a task
     *
     * @param  string $task_id The id of the task to get the identity links for. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\RestIdentityLink[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listTasksInstanceIdentityLinksWithHttpInfo($task_id)
    {
        $returnType = '\Swagger\Client\Model\RestIdentityLink[]';
        $request = $this->listTasksInstanceIdentityLinksRequest($task_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\RestIdentityLink[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listTasksInstanceIdentityLinksAsync
     *
     * Get all identity links for a task
     *
     * @param  string $task_id The id of the task to get the identity links for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listTasksInstanceIdentityLinksAsync($task_id)
    {
        return $this->listTasksInstanceIdentityLinksAsyncWithHttpInfo($task_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listTasksInstanceIdentityLinksAsyncWithHttpInfo
     *
     * Get all identity links for a task
     *
     * @param  string $task_id The id of the task to get the identity links for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listTasksInstanceIdentityLinksAsyncWithHttpInfo($task_id)
    {
        $returnType = '\Swagger\Client\Model\RestIdentityLink[]';
        $request = $this->listTasksInstanceIdentityLinksRequest($task_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listTasksInstanceIdentityLinks'
     *
     * @param  string $task_id The id of the task to get the identity links for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listTasksInstanceIdentityLinksRequest($task_id)
    {
        // verify the required parameter 'task_id' is set
        if ($task_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_id when calling listTasksInstanceIdentityLinks'
            );
        }

        $resourcePath = '/runtime/tasks/{taskId}/identitylinks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($task_id !== null) {
            $resourcePath = str_replace(
                '{' . 'taskId' . '}',
                ObjectSerializer::toPathValue($task_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateTask
     *
     * Update a task
     *
     * @param  string $task_id task_id (required)
     * @param  \Swagger\Client\Model\TaskRequest $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\TaskResponse
     */
    public function updateTask($task_id, $body = null)
    {
        list($response) = $this->updateTaskWithHttpInfo($task_id, $body);
        return $response;
    }

    /**
     * Operation updateTaskWithHttpInfo
     *
     * Update a task
     *
     * @param  string $task_id (required)
     * @param  \Swagger\Client\Model\TaskRequest $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\TaskResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateTaskWithHttpInfo($task_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\TaskResponse';
        $request = $this->updateTaskRequest($task_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\TaskResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateTaskAsync
     *
     * Update a task
     *
     * @param  string $task_id (required)
     * @param  \Swagger\Client\Model\TaskRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateTaskAsync($task_id, $body = null)
    {
        return $this->updateTaskAsyncWithHttpInfo($task_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateTaskAsyncWithHttpInfo
     *
     * Update a task
     *
     * @param  string $task_id (required)
     * @param  \Swagger\Client\Model\TaskRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateTaskAsyncWithHttpInfo($task_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\TaskResponse';
        $request = $this->updateTaskRequest($task_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateTask'
     *
     * @param  string $task_id (required)
     * @param  \Swagger\Client\Model\TaskRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateTaskRequest($task_id, $body = null)
    {
        // verify the required parameter 'task_id' is set
        if ($task_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_id when calling updateTask'
            );
        }

        $resourcePath = '/runtime/tasks/{taskId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($task_id !== null) {
            $resourcePath = str_replace(
                '{' . 'taskId' . '}',
                ObjectSerializer::toPathValue($task_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateTaskInstanceVariable
     *
     * Update an existing variable on a task
     *
     * @param  string $task_id The id of the task to update the variable for. (required)
     * @param  string $variable_name The name of the variable to update. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\RestVariable
     */
    public function updateTaskInstanceVariable($task_id, $variable_name)
    {
        list($response) = $this->updateTaskInstanceVariableWithHttpInfo($task_id, $variable_name);
        return $response;
    }

    /**
     * Operation updateTaskInstanceVariableWithHttpInfo
     *
     * Update an existing variable on a task
     *
     * @param  string $task_id The id of the task to update the variable for. (required)
     * @param  string $variable_name The name of the variable to update. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\RestVariable, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateTaskInstanceVariableWithHttpInfo($task_id, $variable_name)
    {
        $returnType = '\Swagger\Client\Model\RestVariable';
        $request = $this->updateTaskInstanceVariableRequest($task_id, $variable_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\RestVariable',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateTaskInstanceVariableAsync
     *
     * Update an existing variable on a task
     *
     * @param  string $task_id The id of the task to update the variable for. (required)
     * @param  string $variable_name The name of the variable to update. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateTaskInstanceVariableAsync($task_id, $variable_name)
    {
        return $this->updateTaskInstanceVariableAsyncWithHttpInfo($task_id, $variable_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateTaskInstanceVariableAsyncWithHttpInfo
     *
     * Update an existing variable on a task
     *
     * @param  string $task_id The id of the task to update the variable for. (required)
     * @param  string $variable_name The name of the variable to update. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateTaskInstanceVariableAsyncWithHttpInfo($task_id, $variable_name)
    {
        $returnType = '\Swagger\Client\Model\RestVariable';
        $request = $this->updateTaskInstanceVariableRequest($task_id, $variable_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateTaskInstanceVariable'
     *
     * @param  string $task_id The id of the task to update the variable for. (required)
     * @param  string $variable_name The name of the variable to update. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateTaskInstanceVariableRequest($task_id, $variable_name)
    {
        // verify the required parameter 'task_id' is set
        if ($task_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_id when calling updateTaskInstanceVariable'
            );
        }
        // verify the required parameter 'variable_name' is set
        if ($variable_name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $variable_name when calling updateTaskInstanceVariable'
            );
        }

        $resourcePath = '/runtime/tasks/{taskId}/variables/{variableName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($task_id !== null) {
            $resourcePath = str_replace(
                '{' . 'taskId' . '}',
                ObjectSerializer::toPathValue($task_id),
                $resourcePath
            );
        }
        // path params
        if ($variable_name !== null) {
            $resourcePath = str_replace(
                '{' . 'variableName' . '}',
                ObjectSerializer::toPathValue($variable_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
